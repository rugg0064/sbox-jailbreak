<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Sandbox.Engine</name>
    </assembly>
    <members>
        <member name="P:Sandbox.DataModel.AddonConfig.Directory">
            <summary>
            The directory housing this addon (todo)
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Title">
            <summary>
            The human readable title, for example "Sandbox", "Counter-Strike"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Type">
            <summary>
            The type of addon. Current valid values are "game"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Org">
            <summary>
            The ident of the org that owns this addon. For example "facepunch", "valve".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Ident">
            <summary>
            The ident of this addon. For example "sandbox", "cs" or "dm98"
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.FullIdent">
            <summary>
            Returns a combination of Org and Ident - for example "facepunch.sandbox" or "valve.cs".
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Schema">
            <summary>
            The version of the addon file. Allows us to upgrade internally.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.HasAssets">
            <summary>
            If this addon contains models, textures, sounds etc, this should be set to true.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.AssetsPath">
            <summary>
            A relative path to the assets folder in your addon. HasAssets should be set to true.
            Leave this empty to use the root folder as the root of your addon path.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.HasCode">
            <summary>
            If this addon contains code, this should be set to true
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.CodePath">
            <summary>
            A relative path to the code for your addon. HasCode should be set to true.
            Leave this empty if you want the root folder to host your code.
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.RootNamespace">
            <summary>
            For code, the default root namespace to use
            </summary>
        </member>
        <member name="P:Sandbox.DataModel.AddonConfig.Metadata">
            <summary>
            Metadata
            </summary>
        </member>
        <member name="M:Sandbox.BaseGame.TryLoadConfig(Sandbox.BaseFileSystem)">
            <summary>
            Tries to load the addon config from the passed path. Returns null on fail.
            </summary>
        </member>
        <member name="P:Sandbox.BaseGame.IsTransient">
            <summary>
            True if this is a an addon that was downloaded and 
            should be unmounted and destroyed when leaving the game.
            </summary>
        </member>
        <member name="P:Sandbox.LocalAddon.Path">
            <summary>
            Absolute path to the .addon file
            </summary>
        </member>
        <member name="M:Sandbox.RuntimeGame.Recompile">
            <summary>
            Force the assembly to be recompiled
            </summary>
        </member>
        <member name="M:Sandbox.RuntimeGame.OnCodeChanged">
            <summary>
            Called by the filesystem when the code has changed
            </summary>
        </member>
        <member name="M:Sandbox.RuntimeGame.GetDependancies">
            <summary>
            Return a list of installed addons that we depend on. This will only return installed addons.
            If we have missing dependancies you won't find out about it here.
            </summary>
        </member>
        <member name="M:Sandbox.RuntimeGame.GetNetworkShares">
            <summary>
            Return a list of files to send to the network client.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SearchPath.Path">
            <summary>
            Absolute path
            </summary>
        </member>
        <member name="P:Sandbox.Engine.SearchPath.PathId">
            <summary>
            ie "GAME", "MOD"
            </summary>
        </member>
        <member name="M:Sandbox.Engine.SearchPath.Add(System.String,System.String,System.Boolean)">
            <summary>
            Add a search path to the engine if it doesn't already exist. Adds it to an internal
            list so we can clean it up using Clear() after we're done.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.SearchPath.Clear">
            <summary>
            Unmount all paths mounted using Add.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.PreInit(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Called before anything else. This should should set up any low level stuff that
            might be relied on if static functions are called. 
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.TaskScheduler_UnobservedTaskException(System.Object,System.Threading.Tasks.UnobservedTaskExceptionEventArgs)">
            <summary>
            Called on exceptions from a task (delayed, because it'll only get called when the exception gets collected)
            TODO: Move this somewhere else
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Bootstrap.Init">
            <summary>
            Called to initialize the engine.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IBaseDll.OnPackagedDll(System.Span{System.Byte},System.Span{System.Byte},System.String)">
            <summary>
            Load a packaged dll
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IClientDll.RunCommandFromInputBuffer(System.Int32,System.String)">
            <summary>
            A command has been run from the input service
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IClientDll.HandleInputEvent(NativeEngine.InputEvent)">
            <summary>
            Return true if the input was swallowed
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IMenuDll.RunCommandFromInputBuffer(System.Int32,System.String)">
            <summary>
            A command has been run from the input service
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IMenuDll.HandleInputEvent(NativeEngine.InputEvent)">
            <summary>
            Return true if the input was swallowed
            </summary>
        </member>
        <member name="P:Sandbox.Engine.ServerContext.GamemodeIdent">
            <summary>
            The addon ident of the current gamemode
            </summary>
        </member>
        <member name="P:Sandbox.Engine.ServerContext.MapIdent">
            <summary>
            The addon ident of the current map
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IServerDll.OnAddonsCompiled(Sandbox.Compiler[])">
            <summary>
            Called when a batch of compilers are compiled.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IServerDll.UserVarFromClient(System.Int32,System.String,System.String)">
            <summary>
            A client's userdata value has been updated
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IServerDll.ServerLoadStart">
            <summary>
            Server is starting to load, kick it off
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IServerDll.ServerLoadLoop">
            <summary>
            Server is loading, return true to finish loading
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IServerDll.LocalClientDisconnected">
            <summary>
            Local client disconnected from some server, for any reason
            </summary>
        </member>
        <member name="M:Sandbox.Engine.IToolsDll.OnAddonsCompiled(Sandbox.Compiler[])">
            <summary>
            Called when a batch of compilers are compiled.
            </summary>
        </member>
        <member name="T:Sandbox.Engine.SandboxedLoadContext">
            <summary>
            A LoadContext holds a bunch of instanced assemblies. These assemblies and the types within
            are seperate from each other. This means we can load two Sandbox.Event dlls and the globals
            will be different in both. This is good for different realms of addons where we want them to
            all be separate.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Input.GetKeyWithBinding(System.String)">
            <summary>
            Returns the name of a key that is bound to this value
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Input.GetBindingForButton(System.String)">
            <summary>
            Returns the binding for this key
            </summary>
        </member>
        <member name="T:Sandbox.Engine.Controller">
            <summary>
            Represents a controller from Steam Input.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Controller.All">
            <summary>
            All connected controllers.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Controller.First">
            <summary>
            Easy accessor to the first connected controller.
            Elaborate on this stuff more if adding multi controller support.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.#ctor(Steamworks.Data.InputHandle_t)">
            <summary>
            Initialize a Controller from a Steam Input handle.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Controller.Connected">
            <summary>
            If the controller is temporarily disconnected and reconnected this Controller will be revived.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.Init">
            <summary>
            Initialize the Steam Input API and load it's action manifest file.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.Tick(System.Boolean)">
            <summary>
            Update the action set of controllers depending on if they're ingame or not.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Controller.ActionSet">
            <summary>
            Reconfigure the controller to use the specified action set (ie 'Menu', 'Walk' or 'Drive')
            </summary>
            <remarks>
            It's often easier to repeatedly call in your state loops instead of trying to place it in all of your state transitions.
            </remarks>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetDigitalActionState(System.String)">
            <summary>
            Gets the current state of a digital action.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetAnalogActionState(System.String)">
            <summary>
            Gets the current state of an analog action.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetMotionState">
            <summary>
            Returns raw motion data for the specified controller.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetDigitalActionName(System.String)">
            <summary>
            Returns a localized string (from Steam's language setting) for the user-facing action name corresponding
            to the specified action
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetAnalogActionName(System.String)">
            <summary>
            Returns a localized string (from Steam's language setting) for the user-facing action name corresponding
            to the specified action
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetDigitalActionOriginName(System.String)">
            <summary>
            Gets a controller-specific button name of a digital action.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetAnalogActionOriginName(System.String)">
            <summary>
            Gets a controller-specific button name of an analog action.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetDigitalActionGlyph(System.String,Steamworks.GlyphSize,Steamworks.SteamInputGlyphStyle)">
            <summary>
            Gets a controller-specific glyph texture of a digital action.
            </summary>
            <remarks>This is cheap to call and should be done every frame since these can change with action sets or configuration changes.</remarks>
            <returns>Null if user does not have the action bound to anything.</returns>
        </member>
        <member name="M:Sandbox.Engine.Controller.GetAnalogActionGlyph(System.String,Steamworks.GlyphSize,Steamworks.SteamInputGlyphStyle)">
            <summary>
            Gets a controller-specific glyph texture of an analog action.
            </summary>
            <remarks>This is cheap to call and should be done every frame since these can change with action sets or configuration changes.</remarks>
            <returns>Null if user does not have the action bound to anything.</returns>
        </member>
        <member name="M:Sandbox.Engine.Controller.TriggerVibration(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Trigger a vibration event on support controllers including Xbox trigger impusle rumble.
            </summary>
            <remarks>
            Steam Input will translate these commands into haptic pulses for the Steam Controller or Steam Deck.
            </remarks>
            <param name="leftMotor">The speed of the left motor, between 0.0 and 1.0.</param>
            <param name="rightMotor">The speed of the right motor, between 0.0 and 1.0.</param>
            <param name="leftTrigger">(Xbox One controller only) The speed of the left trigger motor, between 0.0 and 1.0.</param>
            <param name="rightTrigger">(Xbox One controller only) The speed of the right trigger motor, between 0.0 and 1.0.</param>
        </member>
        <member name="M:Sandbox.Engine.Controller.SetLEDColor(Color32)">
            <summary>
            Set the controller LED color on supported controllers.
            Steam will handle the behavior on exit of your program so you don't need to try restore the default as you are shutting down.
            </summary>
            <remarks>PS4/PS5 controllers are only ones that support this.</remarks>
        </member>
        <member name="M:Sandbox.Engine.Controller.ShowBindingPanel">
            <summary>
            Invokes the Steam overlay and brings up the binding screen if the user is using Big Picture Mode.
            If the user is not in Big Picture Mode it will open up the binding in a new window.
            
            The Steam Input configurator screen uses in-game actions that the player performs in your game, instead of keys or buttons.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Mouse.CapturedMouseDelta">
            <summary>
            When the mouse is captured we can use this to work out the move delta.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Mouse.TickVisible(System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Sandbox.Engine.Mouse.SetWantsInput(System.Int32,System.Boolean)">
            <summary>
            Called by the context
            </summary>
        </member>
        <member name="F:Sandbox.Engine.MouseMode.Visible">
            <summary>
            Want the mouse cursor to be visible
            </summary>
        </member>
        <member name="F:Sandbox.Engine.MouseMode.Input">
            <summary>
            Want the mouse cursor to swallow input
            </summary>
        </member>
        <member name="F:Sandbox.Engine.MouseMode.Capture">
            <summary>
            Want to capture the mouse input exclusively
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.Username">
            <summary>
            Your own username
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.UserId">
            <summary>
            Your own user id
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.ServiceType">
            <summary>
            The service type (ie "Twitch")
            </summary>
        </member>
        <member name="P:Sandbox.Engine.Streamer.IsActive">
            <summary>
            Are we connected to a service
            </summary>
        </member>
        <member name="T:Sandbox.Engine.WebSocket">
            <summary>
            A WebSocket client for connecting to external services.
            </summary>
            <remarks>
            Events handlers will be called on the synchronization context that <see cref="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)"/> was called on.
            </remarks>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.MessageReceivedHandler">
            <summary>
            Event handler which processes text messages from the WebSocket service.
            </summary>
            <param name="message">The message text that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DataReceivedHandler">
            <summary>
            Event handler which processes binary messages from the WebSocket service.
            </summary>
            <param name="data">The binary message data that was received.</param>
        </member>
        <member name="T:Sandbox.Engine.WebSocket.DisconnectedHandler">
            <summary>
            Event handler which fires when the WebSocket disconnects from the server.
            </summary>
            <param name="status">The close status code from the server, or 0 if there was none. See known values here: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</param>
            <param name="reason">The reason string for closing the connection. This may not be populated, may be from the server, or may be a client exception message.</param>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.IsConnected">
            <summary>
            Returns true as long as a WebSocket connection is established.
            </summary>
        </member>
        <member name="P:Sandbox.Engine.WebSocket.SubProtocol">
            <summary>
            Get the sub-protocol that was negotiated during the opening handshake.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnMessageReceived">
            <summary>
            Event which fires when a text message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDataReceived">
            <summary>
            Event which fires when a binary message is received from the server.
            </summary>
        </member>
        <member name="E:Sandbox.Engine.WebSocket.OnDisconnected">
            <summary>
            Event which fires when the connection to the WebSocket service is lost, for any reason.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.#ctor(System.Int32)">
            <summary>
            Initialized a new WebSocket client.
            </summary>
            <param name="maxMessageSize">The maximum message size to allow from the server, in bytes. Default 64 KiB.</param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Dispose">
            <summary>
            Cleans up resources used by the WebSocket client. This will also immediately close the connection if it is currently open.
            </summary>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.AddSubProtocol(System.String)">
            <summary>
            Add a sub-protocol to be negotiated during the WebSocket connection handshake.
            </summary>
            <param name="protocol"></param>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Connect(System.String,System.Threading.CancellationToken)">
            <summary>
            Establishes a connection to an external WebSocket service.
            </summary>
            <param name="websocketUri">The WebSocket URI to connect to. For example, "ws://hostname.local:1280/" for unencrypted WebSocket or "wss://hostname.local:1281/" for encrypted.</param>
            <param name="ct">A <see cref="T:System.Threading.CancellationToken"/> which allows the connection attempt to be aborted if necessary.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> which completes when the connection is established, or throws if it failed to connect.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.String)">
            <summary>
            Sends a text message to the WebSocket server.
            </summary>
            <param name="message">The message text to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Byte[])">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <remarks>
            The <see cref="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})"/> and <see cref="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})"/> overloads allow sending subsections of byte arrays.
            </remarks>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.ArraySegment{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send. Must not be null.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.Engine.WebSocket.Send(System.Span{System.Byte})">
            <summary>
            Sends a binary message to the WebSocket server.
            </summary>
            <param name="data">The message data to send.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> which completes when the message was queued to be sent.</returns>
        </member>
        <member name="M:Sandbox.ServerAddons.Init">
            <summary>
            Initialize the addon manager
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.ClearTransients">
            <summary>
            Remove all addons
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.Add(System.String,Sandbox.BaseFileSystem,System.Boolean)">
            <summary>
            Add a new addon from a filesystem
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.Add(Sandbox.BaseGame)">
            <summary>
            Add a new addon
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.AddFolder(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Create an addon from folder
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.TryAdd(Sandbox.LocalAddon)">
            <summary>
            Add all child folders as addons
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.Tick">
            <summary>
            This function is made to run in a tick so we can call it in a sensible place
            and not have hotloading start randomly in a task, where it might be unsafe.
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.CompileAndHotloadAsync">
            <summary>
            Compile all pending compiles and do the hotload. This function
            is used in unit tests.
            </summary>
        </member>
        <member name="P:Sandbox.ServerAddons.LastGamemodeAddon">
            <summary>
            The last activated gamemode addon (serverside)
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.SwitchGamemode(System.String,System.Boolean)">
            <summary>
            Switch the gamemode to this one (if found).
            This means activating this gamemode addon, and any
            other addons that want to be activated when this one is.
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.DeactivateAll">
            <summary>
            Fuck all addon off
            </summary>
        </member>
        <member name="M:Sandbox.ServerAddons.FindAddonPaths(System.String)">
            <summary>
            For client - return all the paths associated
            </summary>
        </member>
        <member name="M:Sandbox.Api.Commit(Sandbox.GameDescription)">
            <summary>
            Send a game description to the backend. We can update leaderboards and shit from this.
            </summary>
        </member>
        <member name="M:Sandbox.Api.CommitScore(System.String,System.String,System.Int64,System.Single)">
            <summary>
            Commit a player's score to the backend
            </summary>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Api.GetAccountInformation">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="M:Sandbox.Api.SetFavourite(System.String,System.Boolean)">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetPlayerRank(System.Int64,System.String)">
            <summary>
            Send a game description to the backend. We can update leaderboards and shit from this.
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Id">
            <summary>
            The UserId returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Name">
            <summary>
            The Username returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Token">
            <summary>
            The Token returned by the service
            </summary>
        </member>
        <member name="P:Sandbox.Api.ServiceToken.Type">
            <summary>
            The type (ie "Twitch")
            </summary>
        </member>
        <member name="M:Sandbox.Api.GetLinkedService(System.String)">
            <summary>
            Get linked service credentials, ie "twitch". Under the hood, on our server, we will
            probably be renewing the token with the service (assume the token is only good for 2-3 hours).
            </summary>
        </member>
        <member name="T:Sandbox.GameplayResult">
            <summary>
            An enum describing the result of a game
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Id">
            <summary>
            Our steamid, redundant but here for verification
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.OwnerId">
            <summary>
            If we borrowed this game, this is the real owner id
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Banned">
            <summary>
            Currently just indicates if we're VAC banned
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Links">
            <summary>
            A list of services that we have linked
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Memberships">
            <summary>
            A list of organizations of which we're a member
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Played">
            <summary>
            A list of our last played games
            </summary>
        </member>
        <member name="P:Sandbox.AccountInformation.Favourites">
            <summary>
            A list of our favourited games
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.Update">
            <summary>
            Update Current
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.IsFavourite(System.String)">
            <summary>
            Helper - return true if Current.Favourites contains us
            </summary>
        </member>
        <member name="M:Sandbox.AccountInformation.HasOrganization(System.String)">
            <summary>
            Returns true if a user is a member of this organization
            </summary>
        </member>
        <member name="T:Sandbox.ManifestSchema">
            <summary>
            An addon's manifest, describing what files are available
            </summary>
        </member>
        <member name="P:Sandbox.Package.Updated">
            <summary>
            When the entry was last updated. If these are different between packages 
            then something updated on the backend.
            </summary>
        </member>
        <member name="M:Sandbox.Package.Fetch(System.String,System.Boolean)">
            <summary>
            Find package information
            </summary>
        </member>
        <member name="M:Sandbox.Package.FindAsync(System.String)">
            <summary>
            Find the gamemode info. We might already have the information, in which case we'll return a cached version.
            </summary>
        </member>
        <member name="M:Sandbox.Package.GetCachedTitle(System.String)">
            <summary>
            If we have this package information, try to get its name
            </summary>
        </member>
        <member name="P:Sandbox.Package.Query.Type">
            <summary>
            The type of package to query for
            </summary>
        </member>
        <member name="P:Sandbox.Package.Query.Take">
            <summary>
            The amount of items to return
            </summary>
        </member>
        <member name="P:Sandbox.Package.Query.Skip">
            <summary>
            The amount of items to skip 9for paging)
            </summary>
        </member>
        <member name="M:Sandbox.CodeEditor.OpenSolution(System.String,System.Int32)">
            <summary>
            Called by the menu/tools to jump to code
            </summary>
        </member>
        <member name="M:Sandbox.AccessControl.InitTouches(System.IO.Stream)">
            <summary>
            Clear the touches and fill them with everything this dll touches
            </summary>
        </member>
        <member name="M:Sandbox.AccessControl.ForgetAssembly(System.String)">
            <summary>
            If we're definitely never goinug to see this assembly again (because it's being unloaded for instance)
            We can totally get rid of it and free all that lovely memory.
            </summary>
        </member>
        <member name="M:Sandbox.AccessControl.RemoveLocalTouches">
            <summary>
            Remove touches that are inside addon depends or this dll.
            </summary>
        </member>
        <member name="T:Sandbox.AssemblyTransport">
            <summary>
            
            Assemblies need to be written to bytes to send to the client.
            This keeps that process in one place.
            
            </summary>
        </member>
        <member name="P:Sandbox.CompileManager.NeedsBuild">
            <summary>
            Returns true if we have compiles pending
            </summary>
        </member>
        <member name="P:Sandbox.CompileManager.IsBuilding">
            <summary>
            Returns true if we are currently in the process of building
            </summary>
        </member>
        <member name="M:Sandbox.CompileManager.Shutdown">
            <summary>
            Reset to initial state
            </summary>
        </member>
        <member name="M:Sandbox.CompileManager.MarkForRecompile(Sandbox.Compiler)">
            <summary>
            Mark this assembly as changed. 
            </summary>
        </member>
        <member name="M:Sandbox.CompileManager.BuildAsync">
            <summary>
            Build the compilers. This should only be manually in unit tests.
            </summary>
        </member>
        <member name="T:Sandbox.Compiler">
            <summary>
            Given a folder of .cs files, this will produce (and load) an assembly
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.Active">
            <summary>
            If true, this addon will compile and load
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.Building">
            <summary>
            Is this addon is still building?
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.Name">
            <summary>
            Name of this assembly. This isn't an assembly name - it should not contain ".dll" etc.
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.AssemblyName">
            <summary>
            Generated assembly. This should be NULL until build is called.
            If it's null after build is called then check out BuildResult for errors.
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.Dependancies">
            <summary>
            A list of compilers that we depend upon
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.References">
            <summary>
            References needed for compile
            </summary>
        </member>
        <member name="P:Sandbox.Compiler.GlobalNamespaces">
            <summary>
            Global namespaces
            </summary>
        </member>
        <member name="F:Sandbox.Compiler.BuildResult">
            <summary>
            Results for the assembly build. This can contain warnings or errors.
            </summary>
        </member>
        <member name="M:Sandbox.Compiler.Build(System.Boolean)">
            <summary>
            Build and load the assembly.
            </summary>
        </member>
        <member name="M:Sandbox.Compiler.GetSyntaxTree(System.Collections.Generic.List{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Collect all of the code that should compiled into this assembly
            </summary>
        </member>
        <member name="M:Sandbox.Compiler.ReadTextForgivingAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Read text from a file while dealing with the fact that it might be being saved right 
            when we're loading it so it's likely to throw IOExceptions.
            </summary>
        </member>
        <member name="M:Sandbox.Compiler.FindMetadataReference(System.String)">
            <summary>
            Given a managed assembly name we'll searhc all of the assembly paths and return a MetadataReference. 
            If the dll doesn't exist we'll try to convert the .dll into a .ni.dll. Will report an error if still not found.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Sandbox.Compiler.Unload">
            <summary>
            Unload this assembly. Attempt to remove all created classes and hooks.
            </summary>
        </member>
        <member name="T:Sandbox.GameCompiler">
            <summary>
            Given a folder of .cs files, this will produce (and load) an assembly
            </summary>
        </member>
        <member name="T:Sandbox.ISingletonComponent">
            <summary>
            If a component is marked with this, then only one of that type of component
            will be allowed. When adding a component, it'll automatically replace any others.
            </summary>
        </member>
        <member name="T:Sandbox.DisallowMultipleComponentAttribute">
            <summary>
            Should only allow one of these type of components
            </summary>
        </member>
        <member name="M:Sandbox.Command.GetAutoComplete(System.String)">
            <summary>
            Todo: Add support for managed commands to return shit here
            Todo: We could maybe do this in a cool way, using parameters?
                  So that for example, we could list players if it's a player etc
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.SetString(System.String,System.String)">
            <summary>
            Set a cookie to be stored between sessions. The cookie will expire one month
            from when it was set.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.GetString(System.String,System.String)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.TryGetString(System.String,System.String@)">
            <summary>
            Get a stored session cookie.
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Get``1(System.String,``0)">
            <summary>
            Load JSON encodable data from cookies
            </summary>
        </member>
        <member name="M:Sandbox.CookieContainer.Set``1(System.String,``0)">
            <summary>
            Set JSON encodable object to data
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.EnterMainMenu">
            <summary>
            Main menu loop has started
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.LeaveMainMenu">
            <summary>
            Main menu loop has ended
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.EnterGame">
            <summary>
            Start game loop
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.LeaveGame">
            <summary>
            Leave game loop
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.HandleInputEvent(NativeEngine.InputEvent)">
            <summary>
            An input event from the engine has arrived. This could be a mouse move, key press etc.
            We let the menu have a go at it first, if it doesn't swallow it, we pass it to the client.
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.HideLoadingPlaque">
            <summary>
            Called when we're ready to render the world for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.EngineLoop.Exiting">
            <summary>
            Game is closing
            </summary>
        </member>
        <member name="T:Sandbox.BlendMode">
            <summary>
            Blend modes used by the UI system
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Translucent">
            <summary>
            Translucent pass. We're rendering translucent objects in depth sorted order, from back to front.
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.UI">
            <summary>
            After the game is rendered the UI is drawn over the top
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.SunShadow">
            <summary>
            Rendering shadows for the sun
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.Shadow">
            <summary>
            Rendering dynamic shadows
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsTranslucent">
            <summary>
            Translucent effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.EffectsOpaque">
            <summary>
            Opaque effects on the 1/4 texture
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.DepthPrepass">
            <summary>
            Depth prepass to reduce overdraw
            </summary>
        </member>
        <member name="F:Sandbox.SceneLayerType.PostProcess">
            <summary>
            Post process yeah
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.Obb">
            <summary>
            To contain the object's OBB
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.Physics">
            <summary>
            The most expensive option. Work it out using the physics objects. If it's a ragdoll it'll
            contain each physics object.
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.Specified">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.GameCode">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.RotationExpanded">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.CollisionBoundsNotPhysics">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:Sandbox.SurroundingBoundsType.RotationExpandedSequence">
            <summary>
            Fuck knows: Computes the surrounding collision bounds from the current sequence box
            </summary>
        </member>
        <member name="F:Sandbox.TransmitType.Pvs">
            <summary>
            Entity will be networked if it's in a client (or its Pawn's) PVS
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.None">
            <summary>
            Don't test against the depth buffer, show this through everything.
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.TestAndWrite">
            <summary>
            Test against the depth buffer and write to it.
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.NoWrite">
            <summary>
            Test against the depth buffer but don't write to it.
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.GreaterAndWrite">
            <summary>
            Test against only those with higher depth and don't write to the depth buffer.
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.GreaterNoWrite">
            <summary>
            Test against only those with higher depth and write to the depth buffer.
            </summary>
        </member>
        <member name="F:Sandbox.ZBufferMode.EqualNoWrite">
            <summary>
            Test against only those with equal depth and don't write to the depth buffer.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.FindDirectory(System.String,System.String,System.Boolean)">
            <summary>
            Get a list of directories
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.FindFile(System.String,System.String,System.Boolean)">
            <summary>
            Get a list of files
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.DeleteDirectory(System.String,System.Boolean)">
            <summary>
            Delete a folder and optionally all of its contents
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.DeleteFile(System.String)">
            <summary>
            Delete a file
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.CreateDirectory(System.String)">
            <summary>
            Create a directory - or a tree of directories. 
            Returns silently if the directory already exists.
            </summary>
            <param name="folder"></param>
        </member>
        <member name="M:Sandbox.BaseFileSystem.FileExists(System.String)">
            <summary>
            Returns true if the file exists on this filesystem
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.DirectoryExists(System.String)">
            <summary>
             Returns true if the directory exists on this filesystem
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.GetFullPath(System.String)">
            <summary>
            Returns the full physical path to a file or folder on disk,
            or null if it isn't on disk.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.WriteAllText(System.String,System.String)">
            <summary>
            Write the contents to the path. The file will be over-written if the file exists
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadAllText(System.String)">
            <summary>
            Read the contents of path and return it as a string.
            Returns null if file not found.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadAllBytes(System.String)">
            <summary>
            Read the contents of path and return it as a string
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadAllBytesAsync(System.String)">
            <summary>
            Read the contents of path and return it as a string
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadAllTextAsync(System.String)">
            <summary>
            Read the contents of path and return it as a string
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.CreateSubSystem(System.String)">
            <summary>
            Create a sub-filesystem at the specified path
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.OpenWrite(System.String,System.IO.FileMode)">
            <summary>
            Open a file for write. If the file exists we'll overwrite it (by default)
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.OpenRead(System.String,System.IO.FileMode)">
            <summary>
            Open a file for read. Will throw an exception if it doesn't exist.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadJson``1(System.String,``0)">
            <summary>
            Read Json from a file using System.Text.Json.JsonSerializer. This will throw exceptions
            if the file is missing, unacccessible or not valid json.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.ReadJsonOrDefault``1(System.String,``0)">
            <summary>
            The same as ReadJson except will return a default value on missing/error.
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.WriteJson``1(System.String,``0)">
            <summary>
            Convert object to json and write it to the specified file
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.DirectorySize(System.String,System.Boolean)">
            <summary>
            Gets the size in bytes of all the files in a directory
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.CreateAndMount(Sandbox.BaseFileSystem,System.String)">
            <summary>
            Mount this path on the filesystem, so it's accesisble in Mount
            </summary>
        </member>
        <member name="M:Sandbox.BaseFileSystem.FixPath(System.String)">
            <summary>
            Zio wants good paths to start with '/' - so we add it here if it isn't already on
            </summary>
        </member>
        <member name="P:Sandbox.EngineFileSystem.Temporary">
            <summary>
            A place to write files temporarily. This is stored in memory so 
            cleaning up after yourself is a good idea (!)
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Initialize(System.String)">
            <summary>
            Don't try to use the filesystem until you've called this!
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.DoMounts">
            <summary>
            Create Config, Addons, DownloadedFiles mounts. This isn't part of Initialize()
            because it's specific to the game, so we don't want to run it in Unit Tests
            </summary>
        </member>
        <member name="M:Sandbox.EngineFileSystem.Shutdown">
            <summary>
            Should only be called at the very death
            </summary>
        </member>
        <member name="T:Sandbox.FileWatch">
            <summary>
            Watch folders, dispatch events on changed files
            </summary>
        </member>
        <member name="E:Sandbox.FileWatch.OnChanges">
            <summary>
            Called once per batch of files changed
            </summary>
        </member>
        <member name="E:Sandbox.FileWatch.OnChangedFile">
            <summary>
            Called for each file changed
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BaseTransformAttribute.Bone">
            <summary>
            Internal name of the key that dictates which bone to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BaseTransformAttribute.Attachment">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for position/angles.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BaseTransformAttribute.Origin">
            <summary>
            Internal name of the key to store position in, if set, allows the helper to be moved.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.BaseTransformAttribute.Angles">
            <summary>
            Internal name of the key to store angles in, allows the helper to be rotated.
            </summary>
        </member>
        <member name="P:Sandbox.Internal.SharedRendering.RenderRect">
            <summary>
            Set from the menu context to tell the client context where we want to render the main viewport.
            </summary>
        </member>
        <member name="M:Sandbox.FgdWriter.AddFromMetaData(Hammer.MetaDataAttribute[],System.Text.StringBuilder)">
            <summary>
            Create the metadata section, if it has metadata properties
            </summary>
        </member>
        <member name="M:Sandbox.FgdWriter.AddTags(Hammer.MetaDataAttribute[],System.Text.StringBuilder)">
            <summary>
            Create the tags section
            </summary>
        </member>
        <member name="T:Sandbox.ModelArchetype">
            <summary>
            Default model archetypes.
            These types are defined in "tools/model_archetypes.txt".
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.static_prop_model">
            <summary>
            A static model. It can still have collisions, but they do not have physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.animated_model">
            <summary>
            Animated model. Typically no physics.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.physics_prop_model">
            <summary>
            A generic physics enabled model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.jointed_physics_model">
            <summary>
            A ragdoll type model.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.breakable_prop_model">
            <summary>
            A physics model that can be broken into other physics models.
            </summary>
        </member>
        <member name="F:Sandbox.ModelArchetype.generic_actor_model">
            <summary>
            A generic actor/NPC model.
            </summary>
        </member>
        <member name="T:Sandbox.AutoGenerateAttribute">
            <summary>
            Indicates that this type should generate meta data. Tagging your asset with this will
            mean that the .asset file is automatically generated - which means you don't have to do that.
            </summary>
        </member>
        <member name="T:Sandbox.FGDTypeAttribute">
            <summary>
            Overrides the auto generated FGD type.
            </summary>
        </member>
        <member name="M:Sandbox.FGDTypeAttribute.#ctor(System.String,System.String,System.String)">
            <param name="type">The FGD type override.</param>
            <param name="editor">The name of a custom editor to use for this property.</param>
            <param name="editorArgs">Arguments for given editor override. Format depends on each editor.</param>
        </member>
        <member name="T:Sandbox.ResourceTypeAttribute">
            <summary>
            Allows you to specify a string property as a resource type. This will
            give the property a resource finder. Type should be the file extension, ie "vmdl"
            </summary>
        </member>
        <member name="T:Sandbox.BitFlagsAttribute">
            <summary>
            This choices type is bitflags, so we should be able to choose more than one option at a time.
            </summary>
            <remarks>
            TODO: Once this is no longer used in assets it can be deleted.
                  It should be derived from [System.Flags]
            </remarks>
        </member>
        <member name="M:Sandbox.HotloadManager.DoSwap">
            <summary>
            Does the actual hotload
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.Tick">
            <summary>
            Should be called semi regularly, in a semi-safe place. Will perform a hotswap if needed.
            </summary>
        </member>
        <member name="M:Sandbox.HotloadManager.Replace(System.Reflection.Assembly,System.Reflection.Assembly)">
            <summary>
            Lets the hotload system know that something has changed. If we detect that we are
            replacing a dll (instead of just adding one) we'll queue up a swap.
            </summary>
        </member>
        <member name="T:Sandbox.IMenuAddon">
            <summary>
            This is how the engine communicates with the menu system
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.Init">
            <summary>
            Called to initialize the menu system
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.Shutdown">
            <summary>
            Close down the menu, delete everything
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.OnLoadProgress(System.Single,System.String,System.String,System.String)">
            <summary>
            Update the load screen values
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.OnDownloadProgress(System.Int64,System.Int64)">
            <summary>
            Update the load screen download values
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.OnLoadingPackage(Sandbox.Package)">
            <summary>
            Tell the loading screen what package we're loading
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.SetMenuScreen(System.Boolean)">
            <summary>
            Show/Hide the menu screen
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.IsMenuScreenVisible">
            <summary>
            If the menu screen is open
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.SetLoading(System.Boolean)">
            <summary>
            Show/Hide the loading screen
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.Popup(System.String,System.String,System.String)">
            <summary>
            Show a popup
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.GetLoadingInterface(System.String)">
            <summary>
            Get an interface to update a loading status
            </summary>
        </member>
        <member name="M:Sandbox.IMenuAddon.DevNotice(System.String,System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Show a popup
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWString(System.IntPtr,System.Int32)">
            <summary>
            Convert a native utf pointer to a string
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetPointer(System.String)">
            <summary>
            Get a native friendly utf8 pointer
            </summary>
        </member>
        <member name="M:Sandbox.Interop.GetWPointer(System.String)">
            <summary>
            Get a native friendly unicode pointer
            </summary>
        </member>
        <member name="M:Sandbox.Interop.BindingException(System.String,System.String,System.Exception)">
            <summary>
            Called by the binding system to log an exception when calling a binding
            </summary>
        </member>
        <member name="T:Sandbox.IHandle">
            <summary>
            A base interface that all handles should use
            </summary>
        </member>
        <member name="T:Sandbox.HandleCreationData">
            <summary>
            This struct exists to differentiate the constructor of a handle object
            from the regular constructors. This way we can prevent clients creating
            the object manually, but still be able to create them at runtime.
            </summary>
        </member>
        <member name="T:Sandbox.HandleIndex">
            <summary>
            An index that can convert from a handle (int) to a class. This is 
            usually a static on your Handle object called HandleIndex.
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Always">
            <summary>
            This will *ALWAYS* collide
            This group does not generate contacts or interact with any other groups by default
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Never">
            <summary>
            Never collide with anything
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Trigger">
            <summary>
            Trigger layer, never collides with anything, only triggers/interacts
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.ConditionallySolid">
            <summary>
            Conditionally solid means that the collision response will be zero or as defined in the table when there are matching interactions
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Default">
            <summary>
            standard dynamic rigid object, finite mass
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Debris">
            <summary>
            Collides with nothing but world and static stuff
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.DebrisInteractive">
            <summary>
            Collides with everything except other interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionGroup.Interactive">
            <summary>
            Collides with everything except interactive debris or debris
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Player">
            <summary>
            Player hull (movement and trace attacks)
            </summary>
        </member>
        <member name="F:Sandbox.CollisionLayer.Debris">
            <summary>
            Ragdolls etc
            </summary>
        </member>
        <member name="F:Sandbox.MoveType.Physics">
            <summary>
            Use physics simulation
            </summary>
        </member>
        <member name="F:Sandbox.MoveType.Push">
            <summary>
            no clip to world, push and crush
            </summary>
        </member>
        <member name="T:Sandbox.ClientRpcAttribute">
            <summary>
            A method that can be called by the server
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.FrameTime">
            <summary>
            Get the time taken, in seconds, that were required to process the previous frame.
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.BytesAllocated">
            <summary>
            The number of bytes that were allocated on the managed heap in the last frame.
            <remarks>This may not include allocations from threads other than the game thread.</remarks>
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.Gen0Collections">
            <summary>
            Number of generation 0 (fastest) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.Gen1Collections">
            <summary>
            Number of generation 1 (fast) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.Gen2Collections">
            <summary>
            Number of generation 2 (slow) garbage collections were done in the last frame.
            </summary>
        </member>
        <member name="P:Sandbox.PerformanceStats.ApproximateProcessMemoryUsage">
            <summary>
            Approximate working set of this process.
            </summary>
        </member>
        <member name="M:Sandbox.Performance.Scope(System.String)">
            <summary>
            Creates a profile scope in SuperLuminal
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.SpringLinear">
            <summary>
            How springy and tight the joint will be
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MaxLength">
            <summary>
            Maximum length it should be allowed to go
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.MinLength">
            <summary>
            Minimum length it should be allowed to go. At which point it acts a bit like a rod.
            </summary>
        </member>
        <member name="P:Sandbox.SpringJoint.ReferenceMass">
            <summary>
            You shouldn't really ever need to change this, the default works out
            what the reference mass should be based on actual physics.
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsBody">
            <summary>
            Represents a physics object. An entity can have multiple physics objects. See <see cref="P:Sandbox.PhysicsBody.PhysicsGroup">PhysicsGroup</see>.
            A physics objects conists of one or more <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.EnableTouch">
            <summary>
            Allow Touch callbacks to be called
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.ClearShapes">
            <summary>
            Completely remove all shapes
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.RemoveShape(Sandbox.PhysicsShape)">
            <summary>
            Called from Shape.Remove()
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance. 
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.Parent">
            <summary>
            The physics body we are attached to, if any
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.PhysicsGroup">
            <summary>
            The physics group we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.SetSurface(System.String)">
            <summary>
            Sets a physical properties on all child <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsBody.GetDominantSurface">
            <summary>
            Returns the most commonly occuring surface name between all <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see>s of this <see cref="T:Sandbox.PhysicsShape">PhysicsBody</see>.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupName">
            <summary>
            What is this body called in the group?
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsBody.GroupIndex">
            <summary>
            Return the index of this body in its PhysicsGroup
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsGroup">
            <summary>
            Represets a set of <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> objects. Think ragdoll.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsGroup.Sleeping">
            <summary>
            Physics bodies automatically go to sleep after a certain amount of time of inactivity to save on performance. 
            You can use this to wake the body up, or prematurely send it to sleep.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsGroup.SetSurface(System.String)">
            <summary>
            Sets the physical properties of each <see cref="T:Sandbox.PhysicsShape">PhysicsShape</see> of this group.
            </summary>
        </member>
        <member name="E:Sandbox.PhysicsJoint.OnBreak">
            <summary>
            Called when the joint breaks
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.Strength">
            <summary>
            Strength of the linear constraint. If it takes any more energy than this, it'll break
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsJoint.AngularStrength">
            <summary>
            Strength of the angular constraint. If it takes any more energy than this, it'll break
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.CreateFixed(Sandbox.PhysicsPoint,Sandbox.PhysicsPoint)">
            <summary>
            Creates an almost solid constraint between two physics bodies
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.CreateLength(Sandbox.PhysicsPoint,Sandbox.PhysicsPoint,System.Single)">
            <summary>
            Creates a constraint like a rope, where it has no minimum length but its max length is restained
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.CreateSpring(Sandbox.PhysicsPoint,Sandbox.PhysicsPoint,System.Single,System.Single)">
            <summary>
            Creates a constraint that will try to stay the same length, like a spring, or a rod
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsJoint.CreateHinge(Sandbox.PhysicsBody,Sandbox.PhysicsBody,Vector3,Vector3)">
            <summary>
            Creates an axis constraint, like a hinge
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsPoint">
            <summary>
            Used to describe a point on a physics body. This is used for things like joints where
            you want to pass in just a body, or sometimes you want to pass in a body with a specific
            location and rotation to attach to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsPoint.Local(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation local to the body
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsPoint.World(Sandbox.PhysicsBody,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Describe an attachment using a position/rotation from the world
            </summary>
        </member>
        <member name="T:Sandbox.PhysicsShape">
            <summary>
            Represents a basic, convex shape. A <see cref="T:Sandbox.PhysicsBody">PhysicsBody</see> consists of one or more of these.
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.Body">
            <summary>
            The physics body we belong to.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.EnableAllCollision">
            <summary>
            Enable contact, trace and touch
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.DisableAllCollision">
            <summary>
            Disable contact, trace and touch
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsMeshShape">
            <summary>
            Is this a MeshShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsHullShape">
            <summary>
            Is this a HullShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsSphereShape">
            <summary>
            Is this a SphereShape
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.IsCapsuleShape">
            <summary>
            Is this a CapsuleShape
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Collections.Generic.List{Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.UpdateMesh(System.Span{Vector3},System.Span{System.Int32})">
            <summary>
            Recreate the collision mesh (Only if this physics shape is type Mesh)
            </summary>
        </member>
        <member name="P:Sandbox.PhysicsShape.SurfaceMaterial">
            <summary>
            Sets a physical properties of this physics shape.
            </summary>
        </member>
        <member name="M:Sandbox.PhysicsShape.Remove">
            <summary>
            Remove this shape. After calling this the shape should be considered released and not used again.
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSpring.Frequency">
            <summary>
            The stiffness of the spring
            </summary>
        </member>
        <member name="F:Sandbox.PhysicsSpring.Damping">
            <summary>
            The damping ratio of the spring, usually between 0 and 1
            </summary>
        </member>
        <member name="M:Sandbox.Render.GetDynamicVB(System.Boolean)">
            <summary>
            Get the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Render.SetupLighting(Sandbox.SceneObject)">
            <summary>
            Setup the lighting attributes for this object, place them in Render.Attributes
            </summary>
        </member>
        <member name="M:Sandbox.Render.SetupLighting(Sandbox.SceneObject,Sandbox.RenderAttributes)">
            <summary>
            Setup the lighting attributes for this current object. Place them in the targetAttributes
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyDepthBuffer">
            <summary>
            Grabs the current depth buffer and stores it in 'DepthBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.Render.CopyFrameBuffer">
            <summary>
            Grabs the current viewport buffer and stores it in 'FrameBufferCopyTexture'
            </summary>
        </member>
        <member name="M:Sandbox.Render.SetupViewAttributes(Sandbox.SceneWorld,NativeEngine.CRenderAttributes)">
            <summary>
            Called during render to set the attributes for a view. Note that this might be called in a thread
            and shouldn't use any globals. We should be getting all data from the SceneWorld.
            In the future we could pass in the pipeline attributes and use those to determine what should be
            switched on and off too..
            </summary>
        </member>
        <member name="M:Sandbox.RenderContext.#ctor">
            <summary>
            Careful now. This isn't garbage collected, you NEED to call Dispose!
            </summary>
        </member>
        <member name="M:Sandbox.Material.CreateCopy">
            <summary>
            Create a copy of this material
            </summary>
        </member>
        <member name="M:Sandbox.Material.OverrideTexture(System.String,Sandbox.Texture)">
            <summary>
            Override texture parameter (Color, Normal, etc)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetBounds(Vector3,Vector3)">
            <summary>
            Set the render bounds of this mesh, default is infinite
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexRange(System.Int32,System.Int32)">
            <summary>
            Set how many vertices this mesh draws (if there's no index buffer)
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexRange(System.Int32,System.Int32)">
            <summary>
            Set how many indices this mesh draws
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateIndexBuffer(System.Int32,System.Span{System.Int32})">
            <summary>
            Create a index buffer with a number of indices
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferData(System.Span{System.Int32},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetIndexBufferSize(System.Int32)">
            <summary>
            Resize the index buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockIndexBuffer(System.Int32,System.Int32,Sandbox.Mesh.IndexBufferLockHandler)">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Collections.Generic.List{``0})">
            <summary>
            Create a vertex buffer with a number of vertices, an array of vertex attributes can be passed in
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.CreateVertexBuffer``1(System.Int32,Sandbox.VertexAttribute[],System.Span{``0})">
            <summary>
            Create a vertex buffer with a number of vertices, an array of vertex attributes can be passed in
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferData``1(System.Span{``0},System.Int32)">
            <summary>
            Set data of this buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.SetVertexBufferSize(System.Int32)">
            <summary>
            Resize the vertex buffer
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock all the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a specific amount of the memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="M:Sandbox.Mesh.LockVertexBuffer``1(System.Int32,System.Int32,Sandbox.Mesh.VertexBufferLockHandler{``0})">
            <summary>
            Lock a region of memory in this buffer so you can write to it
            </summary>
        </member>
        <member name="P:Sandbox.Model.Bounds">
            <summary>
            Total bounds of all the meshes
            </summary>
        </member>
        <member name="P:Sandbox.Model.PhysicsBounds">
            <summary>
            Total bounds of all the physics shapes
            </summary>
        </member>
        <member name="P:Sandbox.Model.RenderBounds">
            <summary>
            Render view bounds
            </summary>
        </member>
        <member name="M:Sandbox.Model.TryGetData``1(``0@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:ModelDoc.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.TryGetData(System.Type,System.Object@)">
            <summary>
            Tries to extract data from model based on the given type's <see cref="T:ModelDoc.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
            <param name="data">The extracted data, or default on failure.</param>
            <param name="t">The class with <see cref="T:ModelDoc.GameDataAttribute">ModelDoc.GameDataAttribute</see>.</param>
            <returns>true if data was extracted successfully, false otherwise.</returns>
        </member>
        <member name="M:Sandbox.Model.HasData``1">
            <summary>
            Tests if this model has generic data based on given type's <see cref="T:ModelDoc.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            This will be faster than testing this via GetData<![CDATA[<>]]>()
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetData``1">
            <summary>
            Extracts data from model based on the given type's <see cref="T:ModelDoc.GameDataAttribute">ModelDoc.GameDataAttribute</see>.
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetBreakCommands">
            <summary>
            Internal function used to get a list of break commands the model has.
            </summary>
        </member>
        <member name="M:Sandbox.Model.Get(NativeEngine.IModel)">
            <summary>
            Try to make it so only one Model class exists for each model
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetVertices">
            <summary>
            Experimental! Try to get all vertices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.Model.GetIndices">
            <summary>
            Experimental! Try to get all indices from model (meshes need to be compiled with CPU access!)
            https://files.facepunch.com/layla/1b0611b1/sbox_K1HhsZO3yM.png
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithMass(System.Single)">
            <summary>
            Total mass of the physics body (Default is 1000)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithSurface(System.String)">
            <summary>
            Surface property to use for collision
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.WithLodDistance(System.Single)">
            <summary>
            LOD switch distance increment for each LOD level (Default is 50)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionBox(Vector3,System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add box collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionSphere(System.Single,Vector3)">
            <summary>
            Add sphere collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionCapsule(Vector3,Vector3,System.Single)">
            <summary>
            Add capsule collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionHull(Vector3[],System.Nullable{Vector3},System.Nullable{Rotation})">
            <summary>
            Add a CONVEX hull collision shape
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddCollisionMesh(Vector3[],System.Int32[])">
            <summary>
            Add a CONCAVE mesh collision shape (This shape can NOT be physically simulated)
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh)">
            <summary>
            Add a mesh
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[])">
            <summary>
            Add a bunch of meshes
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMesh(Sandbox.Mesh,System.Int32)">
            <summary>
            Add a mesh to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddMeshes(Sandbox.Mesh[],System.Int32)">
            <summary>
            Add a bunch of meshes to a LOD group
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.AddBone(System.String,Vector3,Rotation,System.String)">
            <summary>
            Add a bone to the skeleton
            </summary>
        </member>
        <member name="M:Sandbox.ModelBuilder.Create">
            <summary>
            Finish creation of model
            </summary>
        </member>
        <member name="T:Sandbox.Resource">
            <summary>
            A resource loaded in the engine, such as a <see cref="T:Sandbox.Model"/> or <see cref="T:Sandbox.Material"/>.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.CopyFrom(Sandbox.Texture)">
            <summary>
            Replace our strong handle with a copy of the strong handle of the passed texture
            Which means that this texture will invisbly become that texture.
            I suspect that there might be a decent way to do this in native using the resource system.
            In which case we should change all this code to use that way instead of doing this.
            </summary>
        </member>
        <member name="P:Sandbox.Texture.Size">
            <summary>
            Returns a Vector2 representing the size of the texure (width, height)
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Dispose">
            <summary>
            Will release the handle for this texture. If the texture isn't referenced by anything
            else it'll be released properly. This will happen anyway because it's called in the destructor.
            By calling it manually you're just telling the engine you're done with this texture right now
            instead of waiting for the garbage collector.
            </summary>
        </member>
        <member name="M:Sandbox.Texture.Load(System.String,System.Boolean)">
            <summary>
            This version is able to load http images - but not images from disk
            </summary>
        </member>
        <member name="M:Sandbox.Texture.LoadAsync(Sandbox.BaseFileSystem,System.String,System.Boolean)">
            <summary>
            Load a texture asyncronously. Will return when the texture is loaded and valid.
            This is useful when loading textures from the web.
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithStaticUsage">
            Common methods
            <summary>
            Provides a hint to the GPU that this texture will not be modified
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly(almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMips(System.Int32)">
            <summary>
            Generate amount of mip levels
            </summary>
            <param name="mips">How many mips should be generated for this texture</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.Texture2DBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithStaticUsage">
            Common methods
            <summary>
            Provides a hint to the GPU that this texture will not be modified
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly(almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMips(System.Int32)">
            <summary>
            Generate amount of mip levels
            </summary>
            <param name="mips">How many mips should be generated for this texture</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(System.Int32,System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
            <param name="depth">Depth in pixels</param>
        </member>
        <member name="M:Sandbox.Texture3DBuilder.WithSize(Vector3)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width, Height and Depth in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithStaticUsage">
            Common methods
            <summary>
            Provides a hint to the GPU that this texture will not be modified
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly(almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMips(System.Int32)">
            <summary>
            Generate amount of mip levels
            </summary>
            <param name="mips">How many mips should be generated for this texture</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSize(System.Int32,System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
            <param name="depth">Depth in pixels</param>
        </member>
        <member name="M:Sandbox.TextureArrayBuilder.WithSize(Vector3)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width, Height and Depth in pixels</param>
        </member>
        <member name="M:Sandbox.TextureBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
            <returns>TextureBuilder</returns>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithStaticUsage">
            Common methods
            <summary>
            Provides a hint to the GPU that this texture will not be modified
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSemiStaticUsage">
            <summary>
            Provides a hint to the GPU that this texture will only be updated sometimes
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDynamicUsage">
            <summary>
            Provides a hint to the GPU that this texture will be updated regularly(almost every frame)
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithGPUOnlyUsage">
            <summary>
            Specify the texture to ONLY be used on the GPU on not allow CPU access.
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithUAVBinding">
            <summary>
            Support binding the texture as a Unordered Access View in a compute or pixel shader.
            This is required for binding a texture within a compute shader
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithName(System.String)">
            <summary>
            Provide a name to identify the texture by
            </summary>
            <param name="name">Desired texture name</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[])">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.Byte[],System.Int32)">
            <summary>
            Initialize texture with pre-existing texture data
            </summary>
            <param name="data">Texture data</param>
            <param name="dataLength">How big our texture data is</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithData(System.IntPtr,System.Int32)">
            <summary>
            Create a texture with data using an UNSAFE intptr
            </summary>
            <param name="data">Pointer to the data</param>
            <param name="dataLength">Length of the data</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithFormat(Sandbox.ImageFormat)">
            <summary>
            The internal texture format to use
            </summary>
            <param name="format">Texture format</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenFormat">
            <summary>
            Sets the internal texture format to use the same format as the screen/frame buffer
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithDepthFormat">
            <summary>
            Uses the same depth format as what the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultisample(Sandbox.MultisampleAmount)">
            <summary>
            Define which how much multisampling the current texture should use
            </summary>
            <param name="amount">Multisampling amount</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample2X">
            <summary>
            Sets the texture to use 2x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample4X">
            <summary>
            Sets the texture to use 4x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample6X">
            <summary>
            Sets the texture to use 6x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample8X">
            <summary>
            Sets the texture to use 8x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithMultiSample16X">
            <summary>
            Sets the texture to use 16x multisampling
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithScreenMultiSample">
            <summary>
            Sets the texture to use the same multisampling as whatever the screen/framebuffer uses
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithAnonymous(System.Boolean)">
            <summary>
            Set whether the texture is an anonymous texture or not
            </summary>
            <param name="isAnonymous">Set if it's anonymous or not</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.Finish">
            <summary>
            Build and create the actual texture
            </summary>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(System.Int32,System.Int32)">
            Custom methods
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="width">Width in pixel</param>
            <param name="height">Height in pixels</param>
        </member>
        <member name="M:Sandbox.TextureCubeBuilder.WithSize(Vector2)">
            <summary>
            Create texture with a predefined size
            </summary>
            <param name="size">Width and Height in pixels</param>
        </member>
        <member name="F:Sandbox.TextureLoader.ImageUrl.Loaded">
            <summary>
            For textures loaded from the web we want to keep them around a bit longer
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.Add(Sandbox.Vertex)">
            <summary>
            Add a vertex
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count., 1 is Vertex.Count -1
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddTriangleIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="M:Sandbox.VertexBuffer.AddRawIndex(System.Int32)">
            <summary>
            Add an index. This is relative to the top of the vertex buffer. So 0 is Vertex.Count.
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.LightColor">
            <summary>
            Color and brightness of the light
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.Falloff">
            <summary>
            Attenuation of how much brightness the light loses the more it travels
            </summary>
        </member>
        <member name="P:Sandbox.SceneLight.Radius">
            <summary>
            Radius of the light in units
            </summary>
        </member>
        <member name="P:Sandbox.SceneModel.AnimationTime">
            <summary>
            The current animation time.
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.Update(System.Single)">
            <summary>
            Update this animation. Delta is the time you want to advance, usually RealTime.Delta
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetMaterialGroup(System.String)">
            <summary>
            Set material group to replace materials of the model
            </summary>
        </member>
        <member name="M:Sandbox.SceneModel.SetBodyGroup(System.String,System.Int32)">
            <summary>
            Set which body group to use
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.ExcludeGameLayer">
            <summary>
            Don't render in the opaque/translucent game passes. This is useful when you
            want to only render in the Bloom layer, rather than additionally to it.
            </summary>
        </member>
        <member name="P:Sandbox.SceneObject.SceneObjectFlagAccessor.WantsFrameBufferCopy">
            <summary>
            Automatically sets the "FrameBufferCopyTexture" attribute within the material.
            This does the same thing as Render.CopyFrameBuffer(); except automatically if
            the pass allows for it.
            </summary>
        </member>
        <member name="T:Sandbox.SceneParticles">
            <summary>
            A SceneObject used to render particles.
            We need to be careful with what we do here, becuse this object is created for in-engine particles
            as well as custom scene object particles.
            With custom particles there's no automatic Simulate, or deletion.. You're completely on your own. This
            is perhaps a good thing though, it's maybe what you want to happen. To be completely isolated and completely
            in control. But at the same time maybe it's not and it's something we need to sort out.
            </summary>
        </member>
        <member name="P:Sandbox.SceneParticles.Particles">
            <summary>
            TODO: Lets find a way to expose the IParticleCollection a bit raw'er
            </summary>
        </member>
        <member name="M:Sandbox.ScenePortal.SetBounds(BBox)">
            <summary>
            Sets the bounding size of the ScenePortal
            The ScenePortal will only be rendered when the bounds are visible in player view
            </summary>
        </member>
        <member name="P:Sandbox.SceneSpotLight.SpotCone">
            <summary>
            Sets how much the spot light would spread, with inner and outer cone angles in degrees
            </summary>
        </member>
        <member name="P:Sandbox.SceneWorld.IsTransient">
            <summary>
            If a world is transient, it means it was created by game code, and should
            be deleted at the end of the game session. If they're non transient then 
            they were created in the menu, or by the engine code and will be released
            properly by that code.
            </summary>
        </member>
        <member name="M:Sandbox.StreamPoll.End(System.Boolean)">
            <summary>
            End this poll, you can optionally archive the poll, otherwise just terminate it
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Lock">
            <summary>
            Lock this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Cancel">
            <summary>
            Cancel this prediction
            </summary>
        </member>
        <member name="M:Sandbox.StreamPrediction.Resolve">
            <summary>
            Resolve this prediction and choose winning outcome to pay out channel points
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Following">
            <summary>
            Get following "Who is following us"
            </summary>
        </member>
        <member name="P:Sandbox.StreamUser.Followers">
            <summary>
            Get followers "Who are we following"
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Ban(System.String,System.Int32)">
            <summary>
            Ban user from your chat, the user will no longer be able to chat.
            Optionally specify the duration, a duration of zero means perm ban
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.Unban">
            <summary>
            Unban user from your chat, this allows them to chat again
            (Note: You have to be in your chat for this to work)
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreateClip(System.Boolean)">
            <summary>
            Create a clip of our stream, if we're streaming
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePoll(System.String,System.Int32,System.String[])">
            <summary>
            Start a poll on our channel with multiple choices, save the poll so you can end it later on
            </summary>
        </member>
        <member name="M:Sandbox.StreamUser.CreatePrediction(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create a prediction on our channel to bet with channel points
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Channel">
            <summary>
            The channel the message was sent in
            </summary>
        </member>
        <member name="P:Sandbox.Twitch.IRCMessage.Message">
            <summary>
            Message itself
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage._parameters">
            <summary>
            Command parameters
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.User">
            <summary>
            The user whose message it is
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Hostmask">
            <summary>
            Hostmask of the user
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Command">
            <summary>
            Raw Command
            </summary>
        </member>
        <member name="F:Sandbox.Twitch.IRCMessage.Tags">
            <summary>
            IRCv3 tags
            </summary>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(System.String)">
            <summary>
            Create an INCOMPLETE IrcMessage only carrying username
            </summary>
            <param name="user"></param>
        </member>
        <member name="M:Sandbox.Twitch.IRCMessage.#ctor(Sandbox.Twitch.IRCCommand,System.String[],System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Create an IrcMessage
            </summary>
            <param name="command">IRC Command</param>
            <param name="parameters">Command params</param>
            <param name="hostmask">User</param>
            <param name="tags">IRCv3 tags</param>
        </member>
        <member name="M:Sandbox.Twitch.IRCParser.Parse(System.String)">
            <summary>
            Parses a raw IRC message into a IRCMessage.
            </summary>
        </member>
        <member name="M:Sandbox.ExpirableSynchronizationContext.AllowPersistentTaskMethods(System.Type)">
            <summary>
            Allows any task methods declared by <paramref name="declaringType"/> to persist after
            calls to <see cref="M:Sandbox.ExpirableSynchronizationContext.Expire(Sandbox.ExpirableSynchronizationContext)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ExpirableSynchronizationContext.AllowPersistentTaskMethod(System.Type,System.String)">
            <summary>
            Allows any task methods declared by <paramref name="declaringType"/> with the name
            <paramref name="methodName"/> to persist after calls to <see cref="M:Sandbox.ExpirableSynchronizationContext.Expire(Sandbox.ExpirableSynchronizationContext)"/>.
            </summary>
        </member>
        <member name="P:Sandbox.ExpirableSynchronizationContext.HasExpired">
            <summary>
            When true, any continuations that attempt to run on this instance will
            log an exception, unless whitelisted by <see cref="M:Sandbox.ExpirableSynchronizationContext.AllowPersistentTaskMethod(System.Type,System.String)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.ExpirableSynchronizationContext.CheckValid(System.Object,System.Boolean@)">
            <summary>
            Returns true if <see cref="P:Sandbox.ExpirableSynchronizationContext.HasExpired"/> is false, or if <paramref name="state"/> represents
            a task method that is allowed to persist after context expiry. Logs an error otherwise.
            </summary>
        </member>
        <member name="P:Sandbox.SyncContext.MainThread">
            <summary>
            Current sync context for the main thread. This will be null until <see cref="M:Sandbox.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="P:Sandbox.SyncContext.WorkerThread">
            <summary>
            Current sync context for worker threads. This will be null until <see cref="M:Sandbox.SyncContext.Init"/> has been
            called for the first time.
            </summary>
        </member>
        <member name="M:Sandbox.SyncContext.Init">
            <summary>
            Sets both <see cref="P:Sandbox.SyncContext.MainThread"/> and <see cref="P:System.Threading.SynchronizationContext.Current"/> to be a new
            instance of <see cref="T:Sandbox.ExpirableSynchronizationContext"/>. Only has an effect the first time it's called.
            </summary>
        </member>
        <member name="M:Sandbox.SyncContext.Reset">
            <summary>
            Invalidates <see cref="P:Sandbox.SyncContext.MainThread"/> and <see cref="P:Sandbox.SyncContext.WorkerThread"/>, and replaces
            them with a new instance.
            Any tasks that try to continue on the old instances will log an error, unless they
            are whitelisted with <see cref="M:Sandbox.ExpirableSynchronizationContext.AllowPersistentTaskMethod(System.Type,System.String)"/>.
            </summary>
        </member>
        <member name="M:Sandbox.WorkerThread.Start">
            <summary>
            Starts a bunch of long-running tasks in the worker thread pool that
            keep calling <see cref="M:Sandbox.ExpirableSynchronizationContext.ProcessQueue"/> on
            <see cref="P:Sandbox.SyncContext.WorkerThread"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if tasks are already running.</exception>
        </member>
        <member name="M:Sandbox.WorkerThread.Stop(System.Int32)">
            <summary>
            Forces the tasks created by <see cref="M:Sandbox.WorkerThread.Start"/> to cancel, to be restarted later.
            This doesn't cancel tasks created with Sandbox.TaskSource.RunInThreadAsync, they
            just get suspended until <see cref="M:Sandbox.WorkerThread.Start"/> is called again.
            </summary>
            <param name="millisecondsTimeout">
            Log an error if any tasks take longer than this to return.
            </param>
        </member>
        <member name="M:Sandbox.Utility.Web.DownloadFile(System.String,System.String,System.Threading.CancellationToken,Sandbox.Utility.IWebProgress)">
            <summary>
            Download afile to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.GrabFile(System.String,System.Threading.CancellationToken,Sandbox.Utility.IWebProgress)">
            <summary>
            Download afile to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.Utility.Web.PutAsync(System.IO.Stream,System.String,System.Threading.CancellationToken,Sandbox.Utility.IWebProgress)">
            <summary>
            Download afile to a target filename (todo - progress)
            </summary>
        </member>
        <member name="M:Sandbox.MatrixExtension.SourceToSteamVrCoordinateSystem(Matrix)">
            <summary>
            Converts a <see cref="T:Matrix"/> from Source to SteamVr coordinate system and scale
            </summary>
            <remarks>
            Source: X=fowards, Y=left, Z=up, scale = inches.
            SteamVr: X=right, Y=up, Z=backwards, scale = meters.
            </remarks>
        </member>
        <member name="T:NativeEngine.StringToken">
            <summary>
            Creates and Caches the process of converting strings into uint32's which
            allow us to use CUtlStringToken arguments.
            
            The tokens are just hashes of the string so we're probably safe enough to never 
            clear this, although it is a technical possibility for someone to call functions
            that take a StringToken with millions of random strings to make the Cache so full
            that calling FindOrCreate takes ages. So maybe we want to keep an eye on it.
            </summary>
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.SHOULD_BE_DELETED_BEFORE_WORLD">
            For objects that can't be considered to be "owned" by the world they are in because they
            are owned by a manager. All this flag does is cause a warning when such an object is still
            in the world at world deletion time (a leak).
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.OWNED_BY_ANOTHER_SCENEOBJECT">
            if this flag is set, then the object will not be deleted when deleting the world, and will not be queued for delete. It's assumed that this object is going to be deleted inside of the destructor of another sceneobject
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.PARTIALLY_ALPHA_BLENDED">
            We have a mixture of alpha-blended and non-alpha blended draws
        </member>
        <member name="F:NativeEngine.ESceneObjectTypeFlags.UNIQUE_BATCH_GROUP">
            A unique batch flag that allows objects to draw in a separate batch from their original group
        </member>
        <member name="F:NativeEngine.SceneSystemWellKnownRenderTargetID.SCENE_RTGT_SCRATCH_TEXTURE_8888">
            <summary>
            a scratch render target texture for use for monitor rendering and other temp storage
            </summary>
        </member>
        <member name="T:Hammer.MetaDataAttribute">
            <summary>
            Base attribute which allows adding FGD metadata to classes.
            </summary>
        </member>
        <member name="T:Hammer.FieldMetaDataAttribute">
            <summary>
            Base attribute which allows adding metadata to properties.
            </summary>
        </member>
        <member name="T:Hammer.SkipAttribute">
            <summary>
            Don't expose this to Hammer and other tools.
            </summary>
        </member>
        <member name="T:Hammer.SkipPropertyAttribute">
            <summary>
            A way to hide properties from parent classes in the FGD.
            </summary>
        </member>
        <member name="M:Hammer.SkipPropertyAttribute.#ctor(System.String)">
            <param name="internal_name">The internal/fgd name to skip. Usually all lowecase and with underscores (_) instead of spaces.</param>
        </member>
        <member name="T:Hammer.MinMaxAttribute">
            <summary>
            Makes this propery have a numeric slider with (if the FGD type is numeric) with given min/max values.
            </summary>
        </member>
        <member name="T:Hammer.SolidAttribute">
            <summary>
            This is a brush based enity class. It can only be a mesh tied to an entity.
            </summary>
        </member>
        <member name="T:Hammer.SupportsSolidAttribute">
            <summary>
            This is a point class entity, but does support being a brush entity (a mesh tied to an entity).
            </summary>
        </member>
        <member name="T:Hammer.PathAttribute">
            <summary>
            This is a path class, used with Hammer's Path Tool.
            </summary>
        </member>
        <member name="M:Hammer.PathAttribute.#ctor(System.String,System.Boolean)">
            <param name="nodeClassName">Class name of the node entity.</param>
            <param name="spawnEnts">If set to true, will actually create node entities. If set to false, node data will be serialized to a JSON key-value.</param>
        </member>
        <member name="T:Hammer.PathNodeAttribute">
            <summary>
            This is a path node class. May not necessarily be an entity.
            </summary>
        </member>
        <member name="T:Hammer.AutoApplyMaterialAttribute">
            <summary>
            Apply this material to the mesh when tying one to this class. Typically used for triggers.
            </summary>
        </member>
        <member name="T:Hammer.ModelAttribute">
            <summary>
            This makes it so the model, skin and bodygroups can be set and changed in Hammer.
            </summary>
        </member>
        <member name="P:Hammer.ModelAttribute.Model">
            <summary>
            The default model to be set to.
            </summary>
        </member>
        <member name="P:Hammer.ModelAttribute.BodyGroup">
            <summary>
            The default body group to be set to.
            </summary>
        </member>
        <member name="P:Hammer.ModelAttribute.MaterialGroup">
            <summary>
            The default material group to be set to.
            </summary>
        </member>
        <member name="P:Hammer.ModelAttribute.Archetypes">
            <summary>
            Marks this entity as a representative of a certain model archetype.
            This makes this entity class appear in ModelDoc under given archetype(s), which will be used to decide which entity class to use when dragging models from Hammer's Asset browser.
            </summary>
        </member>
        <member name="T:Hammer.EditorModelAttribute">
            <summary>
            Declare a model to represent this entity in Hammer.
            </summary>
        </member>
        <member name="P:Hammer.EditorModelAttribute.Model">
            <summary>
            The model to display in the editor.
            </summary>
        </member>
        <member name="P:Hammer.EditorModelAttribute.CastShadows">
            <summary>
            Whether the model should cast shadows in the editor.
            </summary>
        </member>
        <member name="P:Hammer.EditorModelAttribute.FixedBounds">
            <summary>
            Don't reorient bounds. This is used for things that have fixed bounds in the game, like info_player_start.
            </summary>
        </member>
        <member name="P:Hammer.EditorModelAttribute.StaticColor">
            <summary>
            Tint color for this editor model instance when the entity it represets is static.
            </summary>
        </member>
        <member name="P:Hammer.EditorModelAttribute.DynamicColor">
            <summary>
            Tint color for this editor model instance when the entity it represets is dynamic.
            </summary>
        </member>
        <member name="T:Hammer.EditorSpriteAttribute">
            <summary>
            Declare a sprite to represent this entity in Hammer.
            </summary>
            <example>
            [Hammer.EditorSprite( "editor/ai_goal_follow.vmat" )]
            </example>
        </member>
        <member name="T:Hammer.ParticleAttribute">
            <summary>
            Tells Hammer that this entity has a particle effect keyvalue that needs to be visualized.
            </summary>
        </member>
        <member name="T:Hammer.PhysicsTypeOverrideMeshAttribute">
            <summary>
            Indicate to the map builder that any meshes associated with the entity should have a mesh physics type.
            </summary>
        </member>
        <member name="T:Hammer.PhysicsSimulatedAttribute">
            <summary>
            Indicate if the entity is simulated in game and should particpate in the pre-settle simulation during map compile.
            Adds a pre-settle keyvalue to this entity class.
            </summary>
        </member>
        <member name="T:Hammer.VisGroup">
            <summary>
            Used to tell Hammer which automatic Visibility Groups an entity should belong to. See <see cref="T:Hammer.VisGroupAttribute">VisGroupAttribute</see>.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Lighting">
            <summary>
            Entities that are primarily lights and that sort of thing.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Sound">
            <summary>
            The purpose of these entities is to emit light and not much else.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Logic">
            <summary>
            Pure logic entities, typically not shown in-game.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Trigger">
            <summary>
            Any sort of trigger volume, these usually don't show up in-game.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Navigation">
            <summary>
            Entities that are related to nav meshes.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Particles">
            <summary>
            The main reason these exist is to create particle systems.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Physics">
            <summary>
            Physics enabled entities.
            </summary>
        </member>
        <member name="F:Hammer.VisGroup.Dynamic">
            <summary>
            Entities that do not move via physics but are still intreactable with or otherwise non static.
            </summary>
        </member>
        <member name="T:Hammer.VisGroupAttribute">
            <summary>
            Makes the entity show up under given automatic visibility group in Hammer.
            </summary>
        </member>
        <member name="T:Hammer.EntityToolAttribute">
            <summary>
            Adds this entity to a given category in Hammer's Entity tool sidebar.
            </summary>
        </member>
        <member name="T:Hammer.DrawAnglesAttribute">
            <summary>
            Draws the movement direction in Hammer.
            </summary>
            <example>
            [Hammer.DrawAngles( "movedir", "movedir_islocal" )]
            </example>
        </member>
        <member name="T:Hammer.DoorHelperAttribute">
            <summary>
            Draws the door movement and the final open position in Hammer.
            </summary>
        </member>
        <member name="T:Hammer.RenderFieldsAttribute">
            <summary>
            Adds the render color and other related options to the entity class in Hammer.
            </summary>
            <example>
            [Hammer.RenderFields]
            </example>
        </member>
        <member name="T:Hammer.FrustumBoundlessAttribute">
            <summary>
            Draws a frustum that doesn't contribute to bounds calculations.
            </summary>
        </member>
        <member name="T:Hammer.SphereAttribute">
            <summary>
            Displays a sphere in Hammer with a radius tied to given property and with given color.
            The sphere's radius can be manipulated in Hammer's 2D views. You can have multiple of these.
            </summary>
        </member>
        <member name="P:Hammer.SphereAttribute.IsLean">
            <summary>
            If set to true, the sphere will appear as 3 circles in 3D view, rather than a wireframe sphere.
            </summary>
        </member>
        <member name="M:Hammer.SphereAttribute.#ctor(System.String,System.UInt32,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="color">Color as an unsigned integer. For example 0xFF99CC, where 0xBBGGRR.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Hammer.SphereAttribute.#ctor(System.String,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="variableName">Name of the variable to use as sphere radius.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="M:Hammer.SphereAttribute.#ctor(System.Single,System.Byte,System.Byte,System.Byte,System.Boolean)">
            <param name="radius">Range of the sphere to show.</param>
            <param name="red">Red component of the sphere's color.</param>
            <param name="green">Green component of the sphere's color.</param>
            <param name="blue">Blue component of the sphere's color.</param>
            <param name="singleSelect">If this helper should show up when only 1 object is selected in Hammer.</param>
        </member>
        <member name="T:Hammer.TextAttribute">
            <summary>
            Displays text in Hammer on the entity.
            </summary>
        </member>
        <member name="M:Hammer.TextAttribute.#ctor(System.String,System.String,System.Boolean)">
            <param name="text">The text to display.</param>
            <param name="offsetVariable">The name of the property that will act as the position of the text.</param>
            <param name="worldspace">Whether the position from the variable should be interpreted in world space (true) or in local space (false).</param>
        </member>
        <member name="T:Hammer.LineAttribute">
            <summary>
            Draws a line in Hammer. You can have multiple of this attribute.
            </summary>
        </member>
        <member name="M:Hammer.LineAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between this entity and all entites which have a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>'.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="M:Hammer.LineAttribute.#ctor(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Draws lines between all entites, starting from each entity that has a key named '<paramref name="startKey">startKey</paramref>' and its value matches
            the value of our '<paramref name="startKeyValue">startKeyValue</paramref>' and going to each entity that has a key named <paramref name="endKey">endKey</paramref>
            with a value of '<paramref name="endKeyValue">endKeyValue</paramref>'s value.
            </summary>
            <param name="startKey">Name of the key to search on other entities. This typically will be 'targetname'.</param>
            <param name="startKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="endKey">Name of the key to search on other entities.</param>
            <param name="endKeyValue">Name of our key whose value will be used to match other entities.</param>
            <param name="onlySelected">Only draw the line when the entity is selected.</param>
        </member>
        <member name="T:Hammer.BoxSizeAttribute">
            <summary>
            For point entities without visualization (model/sprite), sets the size of the box the entity will appear as in Hammer.
            </summary>
        </member>
        <member name="T:Hammer.BoundsHelperAttribute">
            <summary>
            Creates a resizable box helper in Hammer which outputs the size of the bounding box defined by the level designer into given keys/properties.
            You can have multiple of this attribute.
            </summary>
        </member>
        <member name="M:Hammer.BoundsHelperAttribute.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as mins and maxs
            </summary>
            <param name="minsKey">The internal key name to output "mins" size to.</param>
            <param name="maxsKey">The internal key name to output "maxs" size to.</param>
            <param name="autoCenter">If set to true, editing this box in Hammer will automatically move the entity to the center of the box.</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="M:Hammer.BoundsHelperAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a box helper that outputs the size of the bounding box defined by the level designer as extents (maxs - mins).
            This assumes the entity is in the center of the box.
            </summary>
            <param name="extentsKey">The internal key name to output "extents" size to. This is the result of (maxs - mins).</param>
            <param name="worldAliged">If set, the helper box will ignore entity rotation.</param>
        </member>
        <member name="T:Hammer.OrthoBoundsHelperAttribute">
            <summary>
            Creates a resizable box helper that represents an orhographic projection from the entity's origin in Hammer.
            The size of the bounding box as defined by the level designer is put into given keys/properties.
            </summary>
        </member>
        <member name="T:Hammer.CanBeClientsideOnlyAttribute">
            <summary>
            Adds a property in Hammer that dictates whether the entity will be spawned on server or client.
            </summary>
        </member>
        <member name="T:Hammer.EntityReportSourceAttribute">
            <summary>
            Makes value of this property appear in the Source File column of the Entity Report dialog in Hammer.
            There can be only one of such properties.
            </summary>
        </member>
        <member name="T:Hammer.LightAttribute">
            <summary>
            Internally marks this class in Hammer as a light.
            </summary>
        </member>
        <member name="T:Hammer.LightConeAttribute">
            <summary>
            The light_spot visualizer.
            </summary>
        </member>
        <member name="T:Hammer.SimpleHelperAttribute">
            <summary>
            Adds a simple parameterless helper to the entity class.
            </summary>
        </member>
        <member name="T:Hammer.BakeAmbientLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Hammer.BakeAmbientOcclusionAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Hammer.BakeSkyLightAttribute">
            <summary>
            Used by light_environment entity internally.
            </summary>
        </member>
        <member name="T:Editor.EnableColorAlphaAttribute">
            <summary>
            If used on a Color or Color32 property, enables alpha modification in editors.
            </summary>
        </member>
        <member name="T:ModelDoc.GameDataAttribute">
            <summary>
            Indicates that this class/struct should be available as GenericGameData node in ModelDoc
            </summary>
        </member>
        <member name="P:ModelDoc.GameDataAttribute.AllowMultiple">
            <summary>
            Indicates that this type compiles as list, rather than a single entry in the model.
            This will also affect how you retrieve this data via Model.GetData().
            </summary>
        </member>
        <member name="T:ModelDoc.AxisAttribute">
            <summary>
            Draws 3 line axis visualization, which can set up to be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:ModelDoc.AxisAttribute.Enabled">
            <summary>
            Internal name of a boolean key that dictates whether this helper should draw or not. If unset, will draw always.
            </summary>
        </member>
        <member name="P:ModelDoc.AxisAttribute.ParentLine">
            <summary>
            If set to true, when the node is selected a line will be drawn from the helper to the parent attachment/bone.
            </summary>
        </member>
        <member name="T:ModelDoc.BoxAttribute">
            <summary>
            Draws a box, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:ModelDoc.BoxAttribute.HideSurface">
            <summary>
            If set, the semi-transparent box "walls" will not be drawn.
            </summary>
        </member>
        <member name="P:ModelDoc.BoxAttribute.ShowGizmos">
            <summary>
            If set, gizmos will be shown in transform mode to quickly move/scale the box.
            For "dimensions" box Origin/Angles must be set.
            </summary>
        </member>
        <member name="M:ModelDoc.BoxAttribute.#ctor(System.String)">
            <summary>
            Store the box's dimensions in a single key, acting as (maxs-mins) which assumes the box's center is at the models origin.
            The box's center can be set up to be movable via "Origin" property and rotatable via "Angles" property.
            </summary>
            <param name="dimensionsKey">Internal name of a key on the node that will store the dimensions of the box.</param>
        </member>
        <member name="M:ModelDoc.BoxAttribute.#ctor(System.String,System.String)">
            <summary>
            Store the box's dimensions in 2 keys as Mins and Maxs. This type cannot be rotated.
            </summary>
            <param name="minsKey">Internal name of a key on the node that will store the mins of the box.</param>
            <param name="maxsKey">Internal name of a key on the node that will store the maxs of the box.</param>
        </member>
        <member name="T:ModelDoc.SphereAttribute">
            <summary>
            Draws a sphere, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="P:ModelDoc.SphereAttribute.HideSurface">
            <summary>
            If set, the semi-transparent sphere "wall"/surface will not be drawn.
            </summary>
        </member>
        <member name="T:ModelDoc.CapsuleAttribute">
            <summary>
            Draws a capsule, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:ModelDoc.CapsuleAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:ModelDoc.CapsuleAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:ModelDoc.CylinderAttribute">
            <summary>
            Draws a cylinder, which can be manipulated via gizmos. You can have multiple of these.
            </summary>
        </member>
        <member name="M:ModelDoc.CylinderAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            This variation has 1 radius for both points.
            </summary>
        </member>
        <member name="M:ModelDoc.CylinderAttribute.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            This variation has independent radius for each point.
            </summary>
        </member>
        <member name="T:ModelDoc.HingeJointAttribute">
            <summary>
            A helper that draws axis of rotation and angle limit of a hinge joint.
            </summary>
        </member>
        <member name="P:ModelDoc.HingeJointAttribute.EnableLimit">
            <summary>
            Key name that dictates whether the hinge limit is enabled or not.
            </summary>
        </member>
        <member name="P:ModelDoc.HingeJointAttribute.MinAngle">
            <summary>
            Key name that stores the minimum angle value for the revolute joint.
            </summary>
        </member>
        <member name="P:ModelDoc.HingeJointAttribute.MaxAngle">
            <summary>
            Key name that stores the maximum angle value for the revolute joint.
            </summary>
        </member>
        <member name="T:ModelDoc.EditorWidgetAttribute">
            <summary>
            Adds a custom editor widget to the game data node.
            Currently only 1 option is available - "HandPosePairEditor"
            </summary>
        </member>
        <member name="T:ModelDoc.HandPoseAttribute">
            <summary>
            A helper used for VR hand purposes.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.Origin">
            <summary>
            Internal name of the key to store position in.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.Angles">
            <summary>
            Internal name of the key to store angles in.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.Model">
            <summary>
            Path to a model to use.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.IsRightHand">
            <summary>
            Whether this helper represenets the right hand or not.
            This decides the names of the bones the helper will try to use.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.Label">
            <summary>
            Text label this helper will have when hovered/selected.
            </summary>
        </member>
        <member name="P:ModelDoc.HandPoseAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="M:ModelDoc.HandPoseAttribute.#ctor(System.String,System.String,System.String,System.Boolean)">
            <param name="originKey">Internal name of the key to store position in.</param>
            <param name="anglesKey">Internal name of the key to store angles in.</param>
            <param name="model">Path to a model to use.</param>
            <param name="isRightHand">Whether this helper represenets the right hand or not. This decides the names of the bones the helper will try to use.</param>
        </member>
        <member name="P:ModelDoc.LineAttribute.BoneFrom">
            <summary>
            Internal name of the key that dictates which bone to use as parent for start position.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.AttachmentFrom">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for start position.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.OriginFrom">
            <summary>
            Internal name of the key to read line start position from.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.BoneTo">
            <summary>
            Internal name of the key that dictates which bone to use as parent for end position.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.AttachmentTo">
            <summary>
            Internal name of the key that dictates which attachment to use as parent for end position.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.OriginTo">
            <summary>
            Internal name of the key to read line end position from.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.Enabled">
            <summary>
            Internal name of the key that controls whether this helper is visible or not.
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.Color">
            <summary>
            A string formatted color for this helper. Format is "255 255 255"
            </summary>
        </member>
        <member name="P:ModelDoc.LineAttribute.Width">
            <summary>
            The width of the line helper
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_Bootstrap_PreInit(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sandbox.Engine.Bootstrap.PreInit( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.SandboxEngine_Bootstrap_Init">
            <summary>
            Sandbox.Engine.Bootstrap.Init( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_EnterMainMenu">
            <summary>
            Sandbox.EngineLoop.EnterMainMenu( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_LeaveMainMenu">
            <summary>
            Sandbox.EngineLoop.LeaveMainMenu( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_EnterGame">
            <summary>
            Sandbox.EngineLoop.EnterGame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_LeaveGame">
            <summary>
            Sandbox.EngineLoop.LeaveGame( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_ShowGameUI">
            <summary>
            Sandbox.EngineLoop.ShowGameUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_HideGameUI">
            <summary>
            Sandbox.EngineLoop.HideGameUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_FrameStart">
            <summary>
            Sandbox.EngineLoop.FrameStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_FrameEnd">
            <summary>
            Sandbox.EngineLoop.FrameEnd( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_FrameStage(System.Double,System.UInt32,System.Int32)">
            <summary>
            Sandbox.EngineLoop.FrameStage( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_PreInput">
            <summary>
            Sandbox.EngineLoop.PreInput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_PostInput">
            <summary>
            Sandbox.EngineLoop.PostInput( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_InitNetworkGameClient(System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.InitNetworkGameClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_InitServerSideClient(System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.InitServerSideClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_StartConnecting">
            <summary>
            Sandbox.EngineLoop.StartConnecting( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_UpdateProgressBar(System.Int64)">
            <summary>
            Sandbox.EngineLoop.UpdateProgressBar( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_HandleInputEvent(NativeEngine.InputEvent)">
            <summary>
            Sandbox.EngineLoop.HandleInputEvent( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_ConvarFromClient(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.ConvarFromClient( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_SimulateUI">
            <summary>
            Sandbox.EngineLoop.SimulateUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_Print(System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.Print( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_LoadStart(System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.LoadStart( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_LoadLoop">
            <summary>
            Sandbox.EngineLoop.LoadLoop( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_HideLoadingPlaque">
            <summary>
            Sandbox.EngineLoop.HideLoadingPlaque( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_ResolveMapName(System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.ResolveMapName( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_ClientDisconnect(System.Int64,System.IntPtr)">
            <summary>
            Sandbox.EngineLoop.ClientDisconnect( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_Exiting">
            <summary>
            Sandbox.EngineLoop.Exiting( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_EngineLoop_UpdateServerDetails">
            <summary>
            Sandbox.EngineLoop.UpdateServerDetails( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_RegisterHandle(System.IntPtr,System.UInt32)">
            <summary>
            Sandbox.HandleIndex.RegisterHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_HandleIndex_FreeHandle(System.Int32)">
            <summary>
            Sandbox.HandleIndex.FreeHandle( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_Shutdown(System.UInt32)">
            <summary>
            Sandbox.INetworkClient.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_OnFullConnect(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.INetworkClient.OnFullConnect( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_OnNet(System.UInt32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.INetworkClient.OnNet( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_ProcessServerInfo(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.INetworkClient.ProcessServerInfo( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_SignOnState_New(System.UInt32,System.Int32,System.Int32)">
            <summary>
            Sandbox.INetworkClient.SignOnState_New( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_SignOnState_Full(System.UInt32)">
            <summary>
            Sandbox.INetworkClient.SignOnState_Full( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkClient_Tick(System.UInt32)">
            <summary>
            Sandbox.INetworkClient.Tick( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkServer_Shutdown(System.UInt32)">
            <summary>
            Sandbox.INetworkServer.Shutdown( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkServer_OnNet(System.UInt32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sandbox.INetworkServer.OnNet( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkServer_Tick(System.UInt32)">
            <summary>
            Sandbox.INetworkServer.Tick( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_INetworkServer_FillServerInfo(System.UInt32,System.IntPtr)">
            <summary>
            Sandbox.INetworkServer.FillServerInfo( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_PhysicsEngine_OnPhysicsJointBreak(System.Int32)">
            <summary>
            Sandbox.PhysicsEngine.OnPhysicsJointBreak( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_RealTime_Update(System.Single)">
            <summary>
            Sandbox.RealTime.Update( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_Start(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Render.Start( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_Finish">
            <summary>
            Sandbox.Render.Finish( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_RenderUI(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sandbox.Render.RenderUI( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_PostProcessPass(System.Int32)">
            <summary>
            Sandbox.Render.PostProcessPass( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_WantsPostProcessPass(System.Int32)">
            <summary>
            Sandbox.Render.WantsPostProcessPass( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_Render_SetupViewAttributes(System.Int32,System.IntPtr)">
            <summary>
            Sandbox.Render.SetupViewAttributes( ... )
            </summary>
        </member>
        <member name="M:Managed.SandboxEngine.Exports.Sandbox_ScnCstmbjctRndr_RenderObject(System.Int32)">
            <summary>
            Sandbox.SceneCustomObjectRender.RenderObject( ... )
            </summary>
        </member>
        <member name="T:Noise">
            <summary>
            All of these functions should return between -1 and 1
            </summary>
        </member>
        <member name="T:Steamworks.CallResult`1">
            <summary>
            An awaitable version of a SteamAPICall_t
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.OnCompleted(System.Action)">
            <summary>
            This gets called if IsComplete returned false on the first call.
            The Action "continues" the async call. We pass it to the Dispatch
            to be called when the callback returns.
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetResult">
            <summary>
            Gets the result. This is called internally by the async shit.
            </summary>
        </member>
        <member name="P:Steamworks.CallResult`1.IsCompleted">
            <summary>
            Return true if complete or failed
            </summary>
        </member>
        <member name="M:Steamworks.CallResult`1.GetAwaiter">
            <summary>
            This is what makes this struct awaitable
            </summary>
        </member>
        <member name="T:Steamworks.ICallbackData">
            <summary>
            Gives us a generic way to get the CallbackId of structs
            </summary>
        </member>
        <member name="M:Steamworks.AuthTicket.Cancel">
            <summary>
            Cancels a ticket. 
            You should cancel your ticket when you close the game or leave a server.
            </summary>
        </member>
        <member name="T:Steamworks.Dispatch">
            <summary>
            Responsible for all callback/callresult handling
            
            This manually pumps Steam's message queue and dispatches those
            events to any waiting callbacks/callresults.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnClientCallback(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Called if an exception happens during a callback/callresult.
            This is needed because the exception isn't always accessible when running
            async.. and can fail silently. With this hooked you won't be stuck wondering
            what happened.
            </summary>
        </member>
        <member name="F:Steamworks.Dispatch.actionsToCall">
            <summary>
            To be safe we don't call the continuation functions while iterating
            the Callback list. This is maybe overly safe because the only way this
            could be an issue is if the callback list is modified in the continuation
            which would only happen if starting or shutting down in the callback.
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessCallback(Steamworks.CallbackType,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            A callback is a general global message
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.CallbackToString(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            Given a callback, try to turn it into a string
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.ProcessResult(Steamworks.CallbackType,System.IntPtr,System.Int32)">
            <summary>
            A result is a reply to a specific command
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.OnCallComplete``1(Steamworks.Data.SteamAPICall_t,System.Action,System.Boolean)">
            <summary>
            Watch for a steam api call
            </summary>
        </member>
        <member name="M:Steamworks.Dispatch.Install``1(System.Action{``0},System.Boolean)">
            <summary>
            Install a global callback. The passed function will get called if it's all good.
            </summary>
        </member>
        <member name="F:Steamworks.Data.LeaderboardDisplay.Numeric">
            <summary>
            The score is just a simple numerical value
            </summary>
        </member>
        <member name="F:Steamworks.Data.LeaderboardDisplay.TimeSeconds">
            <summary>
            The score represents a time, in seconds
            </summary>
        </member>
        <member name="F:Steamworks.Data.LeaderboardDisplay.TimeMilliSeconds">
            <summary>
            The score represents a time, in milliseconds
            </summary>
        </member>
        <member name="F:Steamworks.Data.LeaderboardSort.Ascending">
            <summary>
            The top-score is the lowest number
            </summary>
        </member>
        <member name="F:Steamworks.Data.LeaderboardSort.Descending">
            <summary>
            The top-score is the highest number
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.Port">
            <summary>
            The Port. This is redundant documentation.
            </summary>
        </member>
        <member name="M:Steamworks.Data.NetAddress.AnyIp(System.UInt16)">
            <summary>
            Any IP, specific port
            </summary>
        </member>
        <member name="M:Steamworks.Data.NetAddress.LocalHost(System.UInt16)">
            <summary>
            Localhost IP, specific port
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.Cleared">
            <summary>
            Set everything to zero
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.IsIPv6AllZeros">
            <summary>
            Return true if the IP is ::0.  (Doesn't check port.)
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.IsIPv4">
            <summary>
            Return true if IP is mapped IPv4
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.IsLocalHost">
            <summary>
            Return true if this identity is localhost.  (Either IPv6 ::1, or IPv4 127.0.0.1)
            </summary>
        </member>
        <member name="P:Steamworks.Data.NetAddress.Address">
            <summary>
            Get the Address section
            </summary>
        </member>
        <member name="P:Steamworks.Data.Achievement.State">
            <summary>
            True if unlocked
            </summary>
        </member>
        <member name="P:Steamworks.Data.Achievement.UnlockTime">
            <summary>
            Should hold the unlock time if State is true
            </summary>
        </member>
        <member name="M:Steamworks.Data.Achievement.GetIcon">
            <summary>
            Gets the icon of the achievement. This can return a null image even though the image exists if the image
            hasn't been downloaded by Steam yet. You can use GetIconAsync if you want to wait for the image to be downloaded.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Achievement.GetIconAsync(System.Int32)">
            <summary>
            Gets the icon of the achievement, waits for it to load if we have to
            </summary>
        </member>
        <member name="P:Steamworks.Data.Achievement.GlobalUnlocked">
            <summary>
            Returns the fraction (0-1) of users who have unlocked the specified achievement, or -1 if no data available.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Achievement.Trigger(System.Boolean)">
            <summary>
            Make this achievement earned
            </summary>
        </member>
        <member name="M:Steamworks.Data.Achievement.Clear">
            <summary>
            Reset this achievement to not achieved
            </summary>
        </member>
        <member name="T:Steamworks.Data.DurationControl">
            <summary>
            Sent for games with enabled anti indulgence / duration control, for enabled users. 
            Lets the game know whether persistent rewards or XP should be granted at normal rate, half rate, or zero rate.
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Appid">
            <summary>
            appid generating playtime
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Applicable">
            <summary>
            is duration control applicable to user + game combination
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.PlaytimeInLastFiveHours">
            <summary>
            playtime since most recent 5 hour gap in playtime, only counting up to regulatory limit of playtime, in seconds
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.PlaytimeToday">
            <summary>
            playtime on current calendar day
            </summary>
        </member>
        <member name="P:Steamworks.Data.DurationControl.Progress">
            <summary>
            recommended progress
            </summary>
        </member>
        <member name="P:Steamworks.Data.Leaderboard.Name">
            <summary>
            the name of a leaderboard
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.ReplaceScore(System.Int32,System.Int32[])">
            <summary>
            Submit your score and replace your old score even if it was better
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.SubmitScoreAsync(System.Int32,System.Int32[])">
            <summary>
            Submit your new score, but won't replace your high score if it's lower
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.GetScoresForUsersAsync(Steamworks.SteamId[])">
            <summary>
            Fetches leaderboard entries for an arbitrary set of users on a specified leaderboard.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.GetScoresAsync(System.Int32,System.Int32)">
            <summary>
            Used to query for a sequential range of leaderboard entries by leaderboard Sort.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.GetScoresAroundUserAsync(System.Int32,System.Int32)">
            <summary>
            Used to retrieve leaderboard entries relative a user's entry. If there are not enough entries in the leaderboard 
            before or after the user's entry, Steam will adjust the range to try to return the number of entries requested.
            For example, if the user is #1 on the leaderboard and start is set to -2, end is set to 2, Steam will return the first 
            5 entries in the leaderboard. If The current user has no entry, this will return null.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Leaderboard.GetScoresFromFriendsAsync">
            <summary>
            Used to retrieve all leaderboard entries for friends of the current user
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Join">
            <summary>
            Try to join this room. Will return RoomEnter.Success on success,
            and anything else is a failure
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Leave">
            <summary>
            Leave a lobby; this will take effect immediately on the client side
            other users in the lobby will be notified by a LobbyChatUpdate_t callback
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.InviteFriend(Steamworks.SteamId)">
            <summary>
            Invite another user to the lobby
            will return true if the invite is successfully sent, whether or not the target responds
            returns false if the local user is not connected to the Steam servers
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MemberCount">
            <summary>
            returns the number of users in the specified lobby
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Members">
            <summary>
            Returns current members. Need to be in the lobby to see the users.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetData(System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetData(System.String,System.String)">
            <summary>
            Get data associated with this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.DeleteData(System.String)">
            <summary>
            Removes a metadata key from the lobby
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Data">
            <summary>
            Get all data for this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetMemberData(Steamworks.Friend,System.String)">
            <summary>
            Gets per-user metadata for someone in this lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetMemberData(System.String,System.String)">
            <summary>
            Sets per-user metadata (for the local user implicitly)
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SendChatString(System.String)">
            <summary>
            Sends a string to the chat room
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SendChatBytes(System.Byte[])">
            <summary>
            Sends bytes the the chat room
            this isn't exposed because there's no way to read raw bytes atm, 
            and I figure people can send json if they want something more advanced
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.Refresh">
            <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
            you never do this for lobbies you're a member of, only if your
            this will send down all the metadata associated with a lobby
            this is an asynchronous call
            returns false if the local user is not connected to the Steam servers
            results will be returned by a LobbyDataUpdate_t callback
            if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.MaxMembers">
            <summary>
            Max members able to join this lobby. Cannot be over 250.
            Can only be set by the owner
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.SetGameServer(Steamworks.SteamId)">
            <summary>
            [SteamID variant]
            Allows the owner to set the game server associated with the lobby. Triggers the 
            Steammatchmaking.OnLobbyGameCreated event.
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.GetGameServer(System.UInt32@,System.UInt16@,Steamworks.SteamId@)">
            <summary>
            Gets the details of the lobby's game server, if set. Returns true if the lobby is 
            valid and has a server set, otherwise returns false.
            </summary>
        </member>
        <member name="P:Steamworks.Data.Lobby.Owner">
            <summary>
            You must be the lobby owner to set the owner
            </summary>
        </member>
        <member name="M:Steamworks.Data.Lobby.IsOwnedBy(Steamworks.SteamId)">
            <summary>
            Check if the specified SteamId owns the lobby
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceClose">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceFar">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.FilterDistanceWorldwide">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithKeyValue(System.String,System.String)">
            <summary>
            Filter by specified key/value pair; string parameters
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithLower(System.String,System.Int32)">
            <summary>
            Numerical filter where value is less than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithHigher(System.String,System.Int32)">
            <summary>
            Numerical filter where value is greater than the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must be equal to the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithNotEqual(System.String,System.Int32)">
            <summary>
            Numerical filter where value must not equal the value provided
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.AddNumericalFilter(System.String,System.Int32,Steamworks.LobbyComparison)">
            <summary>
            Test key, initialize numerical filter list if necessary, then add new numerical filter
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.OrderByNear(System.String,System.Int32)">
            <summary>
            Order filtered results according to key/values nearest the provided key/value pair.
            Can specify multiple near value filters; each successive filter is lower priority than the previous.
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithSlotsAvailable(System.Int32)">
            <summary>
            returns only lobbies with the specified number of slots available
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.WithMaxResults(System.Int32)">
            <summary>
            sets how many results to return, the lower the count the faster it is to download the lobby results
            </summary>
        </member>
        <member name="M:Steamworks.Data.LobbyQuery.RequestAsync">
            <summary>
            Run the query, get the matching lobbies
            </summary>
        </member>
        <member name="T:Steamworks.Data.RemotePlaySession">
            <summary>
            Represents a RemotePlaySession from the SteamRemotePlay interface
            </summary>
        </member>
        <member name="P:Steamworks.Data.RemotePlaySession.IsValid">
            <summary>
            Returns true if this session was valid when created. This will stay true even 
            after disconnection - so be sure to watch SteamRemotePlay.OnSessionDisconnected
            </summary>
        </member>
        <member name="P:Steamworks.Data.RemotePlaySession.SteamId">
            <summary>
            Get the SteamID of the connected user
            </summary>
        </member>
        <member name="P:Steamworks.Data.RemotePlaySession.ClientName">
            <summary>
            Get the name of the session client device
            </summary>
        </member>
        <member name="P:Steamworks.Data.RemotePlaySession.FormFactor">
            <summary>
            Get the name of the session client device
            </summary>
        </member>
        <member name="M:Steamworks.Data.Screenshot.TagUser(Steamworks.SteamId)">
            <summary>
            Tags a user as being visible in the screenshot
            </summary>
        </member>
        <member name="M:Steamworks.Data.Screenshot.SetLocation(System.String)">
            <summary>
            Tags a user as being visible in the screenshot
            </summary>
        </member>
        <member name="M:Steamworks.Data.Screenshot.TagPublishedFile(Steamworks.Data.PublishedFileId)">
            <summary>
            Tags a user as being visible in the screenshot
            </summary>
        </member>
        <member name="P:Steamworks.Data.ServerInfo.Tags">
            <summary>
            Gets the individual tags for this server
            </summary>
        </member>
        <member name="M:Steamworks.Data.ServerInfo.AddToHistory">
            <summary>
            Add this server to our history list
            If we're already in the history list, weill set the last played time to now
            </summary>
        </member>
        <member name="M:Steamworks.Data.ServerInfo.QueryRulesAsync">
            <summary>
            If this server responds to source engine style queries, we'll be able to get a list of rules here
            </summary>
        </member>
        <member name="M:Steamworks.Data.ServerInfo.RemoveFromHistory">
            <summary>
            Remove this server from our history list
            </summary>
        </member>
        <member name="M:Steamworks.Data.ServerInfo.AddToFavourites">
            <summary>
            Add this server to our favourite list
            </summary>
        </member>
        <member name="M:Steamworks.Data.ServerInfo.RemoveFromFavourites">
            <summary>
            Remove this server from our favourite list
            </summary>
        </member>
        <member name="T:Steamworks.SteamApps">
            <summary>
            Exposes a wide range of information and actions for applications and Downloadable Content (DLC).
            </summary>
        </member>
        <member name="E:Steamworks.SteamApps.OnDlcInstalled">
            <summary>
            posted after the user gains ownership of DLC and that DLC is installed
            </summary>
        </member>
        <member name="E:Steamworks.SteamApps.OnNewLaunchParameters">
            <summary>
            posted after the user gains executes a Steam URL with command line or query parameters
            such as steam://run/appid//-commandline/?param1=value1(and)param2=value2(and)param3=value3 etc
            while the game is already running.  The new params can be queried
            with GetLaunchQueryParam and GetLaunchCommandLine
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribed">
            <summary>
            Checks if the active user is subscribed to the current App ID
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribedFromFamilySharing">
            <summary>
            Check if user borrowed this game via Family Sharing, If true, call GetAppOwner() to get the lender SteamID
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsLowViolence">
            <summary>
            Checks if the license owned by the user provides low violence depots.
            Low violence depots are useful for copies sold in countries that have content restrictions
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsCybercafe">
            <summary>
            Checks whether the current App ID license is for Cyber Cafes.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsVACBanned">
            <summary>
            CChecks if the user has a VAC ban on their account
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.GameLanguage">
            <summary>
            Gets the current language that the user has set.
            This falls back to the Steam UI language if the user hasn't explicitly picked a language for the title.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.AvailableLanguages">
            <summary>
            Gets a list of the languages the current app supports.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsSubscribedToApp(Steamworks.AppId)">
            <summary>
            Checks if the active user is subscribed to a specified AppId.
            Only use this if you need to check ownership of another game related to yours, a demo for example.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsDlcInstalled(Steamworks.AppId)">
            <summary>
            Checks if the user owns a specific DLC and if the DLC is installed
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.PurchaseTime(Steamworks.AppId)">
            <summary>
            Returns the time of the purchase of the app
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.IsSubscribedFromFreeWeekend">
            <summary>
            Checks if the user is subscribed to the current app through a free weekend
            This function will return false for users who have a retail or other type of license
            Before using, please ask your Valve technical contact how to package and secure your free weekened
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.DlcInformation">
            <summary>
            Returns metadata for all available DLC
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.InstallDlc(Steamworks.AppId)">
            <summary>
            Install/Uninstall control for optional DLC
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.UninstallDlc(Steamworks.AppId)">
            <summary>
            Install/Uninstall control for optional DLC
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.CurrentBetaName">
            <summary>
            Returns null if we're not on a beta branch, else the name of the branch
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.MarkContentCorrupt(System.Boolean)">
             <summary>
             Allows you to force verify game content on next launch.
            
             If you detect the game is out-of-date(for example, by having the client detect a version mismatch with a server),
             you can call use MarkContentCorrupt to force a verify, show a message to the user, and then quit.
             </summary>
        </member>
        <member name="M:Steamworks.SteamApps.InstalledDepots(Steamworks.AppId)">
            <summary>
            Gets a list of all installed depots for a given App ID in mount order
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.AppInstallDir(Steamworks.AppId)">
            <summary>
            Gets the install folder for a specific AppID.
            This works even if the application is not installed, based on where the game would be installed with the default Steam library location.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsAppInstalled(Steamworks.AppId)">
            <summary>
            The app may not actually be owned by the current user, they may have it left over from a free weekend, etc.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.AppOwner">
            <summary>
            Gets the Steam ID of the original owner of the current app. If it's different from the current user then it is borrowed..
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.GetLaunchParam(System.String)">
            <summary>
            Gets the associated launch parameter if the game is run via steam://run/appid/?param1=value1;param2=value2;param3=value3 etc.
            Parameter names starting with the character '@' are reserved for internal use and will always return an empty string.
            Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game, 
            but it is advised that you not param names beginning with an underscore for your own features.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.DlcDownloadProgress(Steamworks.AppId)">
            <summary>
            Gets the download progress for optional DLC.
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.BuildId">
            <summary>
            Gets the buildid of this app, may change at any time based on backend updates to the game.
            Defaults to 0 if you're not running a build downloaded from steam.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.GetFileDetailsAsync(System.String)">
            <summary>
            Asynchronously retrieves metadata details about a specific file in the depot manifest.
            Currently provides:
            </summary>
        </member>
        <member name="P:Steamworks.SteamApps.CommandLine">
            <summary>
            Get command line if game was launched via Steam URL, e.g. steam://run/appid//command line/.
            This method of passing a connect string (used when joining via rich presence, accepting an
            invite, etc) is preferable to passing the connect string on the operating system command
            line, which is a security risk.  In order for rich presence joins to go through this
            path and not be placed on the OS command line, you must set a value in your app's
            configuration on Steam.  Ask Valve for help with this.
            </summary>
        </member>
        <member name="M:Steamworks.SteamApps.IsTimedTrial(System.Int32@,System.Int32@)">
            <summary>
             check if game is a timed trial with limited playtime
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.Init(System.Int32)">
            <summary>
            Initialize the steam client.
            If asyncCallbacks is false you need to call RunCallbacks manually every frame.
            </summary>
        </member>
        <member name="P:Steamworks.SteamClient.IsValid">
            <summary>
            Check if Steam is loaded and accessible.
            </summary>		
        </member>
        <member name="P:Steamworks.SteamClient.IsLoggedOn">
            <summary>
            Checks if the current user's Steam client is connected to the Steam servers.
            If it's not then no real-time services provided by the Steamworks API will be enabled. The Steam 
            client will automatically be trying to recreate the connection as often as possible. When the 
            connection is restored a SteamServersConnected_t callback will be posted.
            You usually don't need to check for this yourself. All of the API calls that rely on this will 
            check internally. Forcefully disabling stuff when the player loses access is usually not a 
            very good experience for the player and you could be preventing them from accessing APIs that do not 
            need a live connection to Steam.
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.SteamId">
            <summary>
            Gets the Steam ID of the account currently logged into the Steam client. This is 
            commonly called the 'current user', or 'local user'.
            A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat 
            rooms, and used to differentiate users in all parts of the Steamworks API.
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.Name">
            <summary>
            returns the local players name - guaranteed to not be NULL.
            this is the same name as on the users community profile page
            </summary>
        </member>
        <member name="P:Steamworks.SteamClient.State">
            <summary>
            gets the status of the current user
            </summary>
        </member>
        <member name="F:Steamworks.SteamClient.AppId">
            <summary>
            returns the appID of the current process
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.RestartAppIfNecessary(System.UInt32)">
            <summary>
            Checks if your executable was launched through Steam and relaunches it through Steam if it wasn't
             this returns true then it starts the Steam client if required and launches your game again through it, 
             and you should quit your process as soon as possible. This effectively runs steam://run/AppId so it 
             may not relaunch the exact executable that called it, as it will always relaunch from the version 
             installed in your Steam library folder/
             Note that during development, when not launching via Steam, this might always return true.
            </summary>
        </member>
        <member name="M:Steamworks.SteamClient.ValidCheck">
            <summary>
            Called in interfaces that rely on this being initialized
            </summary>
        </member>
        <member name="T:Steamworks.SteamFriends">
            <summary>
            Undocumented Parental Settings
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnChatMessage">
            <summary>
            Called when chat message has been received from a friend. You'll need to turn on
            ListenForFriendsMessages to recieve this. (friend, msgtype, message)
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnClanChatMessage">
            <summary>
            Called when a chat message has been received in a Steam group chat that we are in. Associated Functions: JoinClanChatRoom. (friend, msgtype, message)
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnPersonaStateChange">
            <summary>
            called when a friends' status changes
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnGameRichPresenceJoinRequested">
            <summary>
            Called when the user tries to join a game from their friends list
            rich presence will have been set with the "connect" key which is set here
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnGameOverlayActivated">
            <summary>
            Posted when game overlay activates or deactivates
            the game can use this to be pause or resume single player games
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnGameServerChangeRequested">
            <summary>
            Called when the user tries to join a different game server from their friends list
            game client should attempt to connect to specified server when this is received
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnGameLobbyJoinRequested">
            <summary>
            Called when the user tries to join a lobby from their friends list
            game client should attempt to connect to specified lobby when this is received
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnFriendRichPresenceUpdate">
            <summary>
            Callback indicating updated data about friends rich presence information
            </summary>
        </member>
        <member name="E:Steamworks.SteamFriends.OnOverlayBrowserProtocol">
            <summary>
            Dispatched when an overlay browser instance is navigated to a
            protocol/scheme registered by RegisterProtocolInOverlayBrowser()
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenOverlay(System.String)">
            <summary>
            The dialog to open. Valid options are: 
            "friends", 
            "community", 
            "players", 
            "settings", 
            "officialgamegroup", 
            "stats", 
            "achievements".
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenUserOverlay(Steamworks.SteamId,System.String)">
            <summary>
            "steamid" - Opens the overlay web browser to the specified user or groups profile.
            "chat" - Opens a chat window to the specified user, or joins the group chat.
            "jointrade" - Opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API.
            "stats" - Opens the overlay web browser to the specified user's stats.
            "achievements" - Opens the overlay web browser to the specified user's achievements.
            "friendadd" - Opens the overlay in minimal mode prompting the user to add the target user as a friend.
            "friendremove" - Opens the overlay in minimal mode prompting the user to remove the target friend.
            "friendrequestaccept" - Opens the overlay in minimal mode prompting the user to accept an incoming friend invite.
            "friendrequestignore" - Opens the overlay in minimal mode prompting the user to ignore an incoming friend invite.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenStoreOverlay(Steamworks.AppId,Steamworks.OverlayToStoreFlag)">
            <summary>
            Activates the Steam Overlay to the Steam store page for the provided app.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenWebOverlay(System.String,System.Boolean)">
            <summary>
            Activates Steam Overlay web browser directly to the specified URL.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.OpenGameInviteOverlay(Steamworks.SteamId)">
            <summary>
            Activates the Steam Overlay to open the invite dialog. Invitations sent from this dialog will be for the provided lobby.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.SetPlayedWith(Steamworks.SteamId)">
            <summary>
            Mark a target user as 'played with'.
            NOTE: The current user must be in game with the other player for the association to work.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.RequestUserInformation(Steamworks.SteamId,System.Boolean)">
            <summary>
            Requests the persona name and optionally the avatar of a specified user.
            NOTE: It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.
            returns true if we're fetching the data, false if we already have it
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.GetRichPresence(System.String)">
            <summary>
            Find a rich presence value by key for current user. Will be null if not found.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.SetRichPresence(System.String,System.String)">
            <summary>
            Sets a rich presence value by key for current user.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.ClearRichPresence">
            <summary>
            Clears all of the current user's rich presence data.
            </summary>
        </member>
        <member name="P:Steamworks.SteamFriends.ListenForFriendsMessages">
            <summary>
            Listens for Steam friends chat messages.
            You can then show these chats inline in the game. For example with a Blizzard style chat message system or the chat system in Dota 2.
            After enabling this you will receive callbacks when ever the user receives a chat message.
            </summary>
        </member>
        <member name="M:Steamworks.SteamFriends.RegisterProtocolInOverlayBrowser(System.String)">
            <summary>
            Call this before calling ActivateGameOverlayToWebPage() to have the Steam Overlay Browser block navigations
             to your specified protocol (scheme) uris and instead dispatch a OverlayBrowserProtocolNavigation callback to your game.
            </summary>
        </member>
        <member name="T:Steamworks.SteamInput">
            <summary>
            Class for utilizing Steam Input.
            </summary>
        </member>
        <member name="E:Steamworks.SteamInput.OnControllerConnected">
            <summary>
            Controller Connected - provides info about a single newly connected controller
            </summary>
        </member>
        <member name="E:Steamworks.SteamInput.OnControllerDisconnected">
            <summary>
            Controller Disconnected - provides info about a single disconnected controller
            </summary>
        </member>
        <member name="E:Steamworks.SteamInput.OnConfigLoaded">
            <summary>
            Controller configuration loaded - these callbacks will always fire if you have a handler.
            </summary>
        </member>
        <member name="T:Steamworks.SteamInventory">
            <summary>
            Undocumented Parental Settings
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.LoadItemDefinitions">
            <summary>
            Call this if you're going to want to access definition information. You should be able to get 
            away with calling this once at the start if your game, assuming your items don't change all the time.
            This will trigger OnDefinitionsUpdated at which point Definitions should be set.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.WaitForDefinitions(System.Single)">
            <summary>
            Will call LoadItemDefinitions and wait until Definitions is not null
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.FindDefinition(Steamworks.Data.InventoryDefId)">
            <summary>
            Try to find the definition that matches this definition ID.
            Uses a dictionary so should be about as fast as possible.
            </summary>
        </member>
        <member name="P:Steamworks.SteamInventory.Items">
            <summary>
            We will try to keep this list of your items automatically up to date.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.GetAllItems">
            <summary>
            Update the list of Items[]
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.GetAllItemsAsync">
            <summary>
            Get all items and return the InventoryResult
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.GenerateItemAsync(Steamworks.InventoryDef,System.Int32)">
            <summary>
            This is used to grant a specific item to the user. This should 
            only be used for development prototyping, from a trusted server, 
            or if you don't care about hacked clients granting arbitrary items. 
            This call can be disabled by a setting on Steamworks.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.CraftItemAsync(Steamworks.InventoryItem[],Steamworks.InventoryDef)">
            <summary>
            Crafting! Uses the passed items to buy the target item.
            You need to have set up the appropriate exchange rules in your item
            definitions. This assumes all the items passed in aren't stacked.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.CraftItemAsync(Steamworks.InventoryItem.Amount[],Steamworks.InventoryDef)">
            <summary>
            Crafting! Uses the passed items to buy the target item.
            You need to have set up the appropriate exchange rules in your item
            definitions. This assumes all the items passed in aren't stacked.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.DeserializeAsync(System.Byte[],System.Int32)">
            <summary>
            Deserializes a result set and verifies the signature bytes.	
            This call has a potential soft-failure mode where the Result is expired, it will 
            still succeed in this mode.The "expired" 
            result could indicate that the data may be out of date - not just due to timed 
            expiration( one hour ), but also because one of the items in the result set may 
            have been traded or consumed since the result set was generated.You could compare 
            the timestamp from GetResultTimestamp to ISteamUtils::GetServerRealTime to determine
            how old the data is. You could simply ignore the "expired" result code and 
            continue as normal, or you could request the player with expired data to send 
            an updated result set.
            You should call CheckResultSteamID on the result handle when it completes to verify 
            that a remote player is not pretending to have a different user's inventory.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.GrantPromoItemsAsync">
            <summary>
            Grant all promotional items the user is eligible for
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.TriggerItemDropAsync(Steamworks.Data.InventoryDefId)">
            <summary>
            Trigger an item drop for this user. This is for timed drops.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.AddPromoItemAsync(Steamworks.Data.InventoryDefId)">
            <summary>
            Trigger a promo item drop. You can call this at startup, it won't
            give users multiple promo drops.
            </summary>
        </member>
        <member name="M:Steamworks.SteamInventory.StartPurchaseAsync(Steamworks.InventoryDef[])">
            <summary>
            Start buying a cart load of items. This will return a positive result is the purchase has
            begun. You should listen out for SteamUser.OnMicroTxnAuthorizationResponse for a success.
            </summary>
        </member>
        <member name="T:Steamworks.SteamMatchmaking">
            <summary>
            Functions for clients to access matchmaking services, favorites, and to operate on game lobbies
            </summary>
        </member>
        <member name="P:Steamworks.SteamMatchmaking.MaxLobbyKeyLength">
            <summary>
            Maximum number of characters a lobby metadata key can be
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyInvite">
            <summary>
            Someone invited you to a lobby
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyEntered">
            <summary>
            You joined a lobby
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyCreated">
            <summary>
            You created a lobby
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyGameCreated">
            <summary>
            A game server has been associated with the lobby
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyDataChanged">
            <summary>
            The lobby metadata has changed
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberDataChanged">
            <summary>
            The lobby member metadata has changed
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberJoined">
            <summary>
            The lobby member joined
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberLeave">
            <summary>
            The lobby member left the room
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberDisconnected">
            <summary>
            The lobby member left the room
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberKicked">
            <summary>
            The lobby member was kicked. The 3rd param is the user that kicked them.
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnLobbyMemberBanned">
            <summary>
            The lobby member was banned. The 3rd param is the user that banned them.
            </summary>
        </member>
        <member name="E:Steamworks.SteamMatchmaking.OnChatMessage">
            <summary>
            A chat message was recieved from a member of a lobby
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.CreateLobbyAsync(System.Int32)">
            <summary>
            Creates a new invisible lobby. Call lobby.SetPublic to take it online.
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.JoinLobbyAsync(Steamworks.SteamId)">
            <summary>
            Attempts to directly join the specified lobby
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.GetFavoriteServers">
            <summary>
            Get a list of servers that are on your favorites list
            </summary>
        </member>
        <member name="M:Steamworks.SteamMatchmaking.GetHistoryServers">
            <summary>
            Get a list of servers that you have added to your play history
            </summary>
        </member>
        <member name="T:Steamworks.SteamParental">
            <summary>
            Undocumented Parental Settings
            </summary>
        </member>
        <member name="E:Steamworks.SteamParental.OnSettingsChanged">
            <summary>
            Parental Settings Changed
            </summary>
        </member>
        <member name="P:Steamworks.SteamParental.IsParentalLockEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="P:Steamworks.SteamParental.IsParentalLockLocked">
            <summary>
            
            </summary>
        </member>
        <member name="M:Steamworks.SteamParental.IsAppBlocked(Steamworks.AppId)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Steamworks.SteamParental.BIsAppInBlockList(Steamworks.AppId)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Steamworks.SteamParental.IsFeatureBlocked(Steamworks.ParentalFeature)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Steamworks.SteamParental.BIsFeatureInBlockList(Steamworks.ParentalFeature)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Steamworks.SteamRemotePlay">
            <summary>
            Functions that provide information about Steam Remote Play sessions, streaming your game content to another computer or to a Steam Link app or hardware.
            </summary>
        </member>
        <member name="E:Steamworks.SteamRemotePlay.OnSessionConnected">
            <summary>
            Called when a session is connected
            </summary>
        </member>
        <member name="E:Steamworks.SteamRemotePlay.OnSessionDisconnected">
            <summary>
            Called when a session becomes disconnected
            </summary>
        </member>
        <member name="P:Steamworks.SteamRemotePlay.SessionCount">
            <summary>
            Get the number of currently connected Steam Remote Play sessions
            </summary>
        </member>
        <member name="M:Steamworks.SteamRemotePlay.GetSession(System.Int32)">
            <summary>
            Get the currently connected Steam Remote Play session ID at the specified index.
            IsValid will return false if it's out of bounds
            </summary>
        </member>
        <member name="M:Steamworks.SteamRemotePlay.SendInvite(Steamworks.SteamId)">
            <summary>
            Invite a friend to Remote Play Together
            This returns false if the invite can't be sent
            </summary>
        </member>
        <member name="T:Steamworks.SteamScreenshots">
            <summary>
            Undocumented Parental Settings
            </summary>
        </member>
        <member name="E:Steamworks.SteamScreenshots.OnScreenshotRequested">
            <summary>
            A screenshot has been requested by the user from the Steam screenshot hotkey. 
            This will only be called if Hooked is true, in which case Steam 
            will not take the screenshot itself.
            </summary>
        </member>
        <member name="E:Steamworks.SteamScreenshots.OnScreenshotReady">
            <summary>
            A screenshot successfully written or otherwise added to the library and can now be tagged.
            </summary>
        </member>
        <member name="E:Steamworks.SteamScreenshots.OnScreenshotFailed">
            <summary>
            A screenshot attempt failed
            </summary>
        </member>
        <member name="M:Steamworks.SteamScreenshots.WriteScreenshot(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a screenshot to the user's screenshot library given the raw image data, which must be in RGB format.
            The return value is a handle that is valid for the duration of the game process and can be used to apply tags.
            </summary>
        </member>
        <member name="M:Steamworks.SteamScreenshots.AddScreenshot(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Adds a screenshot to the user's screenshot library from disk.  If a thumbnail is provided, it must be 200 pixels wide and the same aspect ratio
            as the screenshot, otherwise a thumbnail will be generated if the user uploads the screenshot.  The screenshots must be in either JPEG or TGA format.
            The return value is a handle that is valid for the duration of the game process and can be used to apply tags.
            JPEG, TGA, and PNG formats are supported.
            </summary>
        </member>
        <member name="M:Steamworks.SteamScreenshots.TriggerScreenshot">
            <summary>
            Causes the Steam overlay to take a screenshot.  
            If screenshots are being hooked by the game then a 
            ScreenshotRequested callback is sent back to the game instead. 
            </summary>
        </member>
        <member name="P:Steamworks.SteamScreenshots.Hooked">
            <summary>
            Toggles whether the overlay handles screenshots when the user presses the screenshot hotkey, or if the game handles them.
            Hooking is disabled by default, and only ever enabled if you do so with this function.
            If the hooking is enabled, then the ScreenshotRequested_t callback will be sent if the user presses the hotkey or 
            when TriggerScreenshot is called, and then the game is expected to call WriteScreenshot or AddScreenshotToLibrary in response.
            </summary>
        </member>
        <member name="T:Steamworks.SteamUser">
            <summary>
            Functions for accessing and manipulating Steam user information.
            This is also where the APIs for Steam Voice are exposed.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnSteamServersConnected">
            <summary>
            Called when a connections to the Steam back-end has been established.
            This means the Steam client now has a working connection to the Steam servers. 
            Usually this will have occurred before the game has launched, and should only be seen if the 
            user has dropped connection due to a networking issue or a Steam server update.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnSteamServerConnectFailure">
            <summary>
            Called when a connection attempt has failed.
            This will occur periodically if the Steam client is not connected, 
            and has failed when retrying to establish a connection.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnSteamServersDisconnected">
            <summary>
            Called if the client has lost connection to the Steam servers.
            Real-time services will be disabled until a matching OnSteamServersConnected has been posted.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnClientGameServerDeny">
            <summary>
            Sent by the Steam server to the client telling it to disconnect from the specified game server, 
            which it may be in the process of or already connected to.
            The game client should immediately disconnect upon receiving this message.
            This can usually occur if the user doesn't have rights to play on the game server.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnLicensesUpdated">
            <summary>
            Called whenever the users licenses (owned packages) changes.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnValidateAuthTicketResponse">
            <summary>
            Called when an auth ticket has been validated. 
            The first parameter is the steamid of this user
            The second is the Steam ID that owns the game, this will be different from the first 
            if the game is being borrowed via Steam Family Sharing
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnGetAuthSessionTicketResponse">
            <summary>
            Used internally for GetAuthSessionTicketAsync
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnMicroTxnAuthorizationResponse">
            <summary>
            Called when a user has responded to a microtransaction authorization request.
            ( appid, orderid, user authorized )
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnGameWebCallback">
            <summary>
            Sent to your game in response to a steam://gamewebcallback/(appid)/command/stuff command from a user clicking a 
            link in the Steam overlay browser.
            You can use this to add support for external site signups where you want to pop back into the browser after some web page 
            signup sequence, and optionally get back some detail about that.
            </summary>
        </member>
        <member name="E:Steamworks.SteamUser.OnDurationControl">
            <summary>
            Sent for games with enabled anti indulgence / duration control, for enabled users.
            Lets the game know whether persistent rewards or XP should be granted at normal rate, 
            half rate, or zero rate.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.VoiceRecord">
            <summary>
            Starts/Stops voice recording.
            Once started, use GetAvailableVoice and GetVoice to get the data, and then call StopVoiceRecording 
            when the user has released their push-to-talk hotkey or the game session has completed.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.HasVoiceData">
            <summary>
            Returns true if we have voice data waiting to be read
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.ReadVoiceData(System.IO.Stream)">
            <summary>
            Reads the voice data and returns the number of bytes written.
            The compressed data can be transmitted by your application and decoded back into raw audio data using 
            DecompressVoice on the other side. The compressed data provided is in an arbitrary format and is not meant to be played directly.
            This should be called once per frame, and at worst no more than four times a second to keep the microphone input delay as low as 
            possible. Calling this any less may result in gaps in the returned stream.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.ReadVoiceDataBytes">
            <summary>
            Reads the voice data and returns the bytes. You should obviously ideally be using
            ReadVoiceData because it won't be creating a new byte array every call. But this 
            makes it easier to get it working, so let the babies have their bottle.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.DecompressVoice(System.IO.Stream,System.Int32,System.IO.Stream)">
            <summary>
            Decodes the compressed voice data returned by GetVoice.
            The output data is raw single-channel 16-bit PCM audio.The decoder supports any sample rate from 11025 to 48000.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.DecompressVoice(System.Byte[],System.IO.Stream)">
            <summary>
            Lazy version
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.DecompressVoice(System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Advanced and potentially fastest version - incase you know what you're doing
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.GetAuthSessionTicket">
            <summary>
            Retrieve a authentication ticket to be sent to the entity who wishes to authenticate you.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.IsBehindNAT">
            <summary>
            Checks if the current users looks like they are behind a NAT device.
            This is only valid if the user is connected to the Steam servers and may not catch all forms of NAT.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.SteamLevel">
            <summary>
            Gets the Steam level of the user, as shown on their Steam community profile.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.GetStoreAuthUrlAsync(System.String)">
            <summary>
            Requests a URL which authenticates an in-game browser for store check-out, and then redirects to the specified URL.
            As long as the in-game browser accepts and handles session cookies, Steam microtransaction checkout pages will automatically recognize the user instead of presenting a login page.
            NOTE: The URL has a very short lifetime to prevent history-snooping attacks, so you should only call this API when you are about to launch the browser, or else immediately navigate to the result URL using a hidden browser window.
            NOTE: The resulting authorization cookie has an expiration time of one day, so it would be a good idea to request and visit a new auth URL every 12 hours.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.IsPhoneVerified">
            <summary>
            Checks whether the current user has verified their phone number.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.IsTwoFactorEnabled">
            <summary>
            Checks whether the current user has Steam Guard two factor authentication enabled on their account.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.IsPhoneIdentifying">
            <summary>
            Checks whether the user's phone number is used to uniquely identify them.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUser.IsPhoneRequiringVerification">
            <summary>
            Checks whether the current user's phone number is awaiting (re)verification.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.RequestEncryptedAppTicketAsync(System.Byte[])">
            <summary>
            Requests an application ticket encrypted with the secret "encrypted app ticket key".
            The encryption key can be obtained from the Encrypted App Ticket Key page on the App Admin for your app.
            There can only be one call pending, and this call is subject to a 60 second rate limit.
            If you get a null result from this it's probably because you're calling it too often.
            This can fail if you don't have an encrypted ticket set for your app here https://partner.steamgames.com/apps/sdkauth/
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.RequestEncryptedAppTicketAsync">
            <summary>
            Requests an application ticket encrypted with the secret "encrypted app ticket key".
            The encryption key can be obtained from the Encrypted App Ticket Key page on the App Admin for your app.
            There can only be one call pending, and this call is subject to a 60 second rate limit.
            This can fail if you don't have an encrypted ticket set for your app here https://partner.steamgames.com/apps/sdkauth/
            </summary>
        </member>
        <member name="M:Steamworks.SteamUser.GetDurationControl">
            <summary>
            Get anti indulgence / duration control
            </summary>
        </member>
        <member name="E:Steamworks.SteamUserStats.OnAchievementIconFetched">
            <summary>
            called when the achivement icon is loaded
            </summary>
        </member>
        <member name="E:Steamworks.SteamUserStats.OnUserStatsReceived">
            <summary>
            called when the latests stats and achievements have been received
            from the server
            </summary>
        </member>
        <member name="E:Steamworks.SteamUserStats.OnUserStatsStored">
            <summary>
            result of a request to store the user stats for a game
            </summary>
        </member>
        <member name="E:Steamworks.SteamUserStats.OnAchievementProgress">
            <summary>
            result of a request to store the achievements for a game, or an 
            "indicate progress" call. If both m_nCurProgress and m_nMaxProgress
            are zero, that means the achievement has been fully unlocked
            </summary>
        </member>
        <member name="E:Steamworks.SteamUserStats.OnUserStatsUnloaded">
            <summary>
            Callback indicating that a user's stats have been unloaded
            </summary>
        </member>
        <member name="P:Steamworks.SteamUserStats.Achievements">
            <summary>
            Get the available achievements
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.IndicateAchievementProgress(System.String,System.Int32,System.Int32)">
            <summary>
            Show the user a pop-up notification with the current progress toward an achievement.
            Will return false if RequestCurrentStats has not completed and successfully returned 
            its callback, if the achievement doesn't exist/has unpublished changes in the app's 
            Steamworks Admin page, or if the achievement is unlocked. 
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.PlayerCountAsync">
            <summary>
            Tries to get the number of players currently playing this game.
            Or -1 if failed.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.StoreStats">
            <summary>
            Send the changed stats and achievements data to the server for permanent storage.
            If this fails then nothing is sent to the server. It's advisable to keep trying until the call is successful.
            This call can be rate limited. Call frequency should be on the order of minutes, rather than seconds.You should only be calling this during major state changes such as the end of a round, the map changing, or the user leaving a server. This call is required to display the achievement unlock notification dialog though, so if you have called SetAchievement then it's advisable to call this soon after that.
            If you have stats or achievements that you have saved locally but haven't uploaded with this function when your application process ends then this function will automatically be called.
            You can find additional debug information written to the %steam_install%\logs\stats_log.txt file.
            This function returns true upon success if :
            RequestCurrentStats has completed and successfully returned its callback AND
            the current game has stats associated with it in the Steamworks Partner backend, and those stats are published.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.RequestCurrentStats">
            <summary>
            Asynchronously request the user's current stats and achievements from the server.
            You must always call this first to get the initial status of stats and achievements.
            Only after the resulting callback comes back can you start calling the rest of the stats 
            and achievement functions for the current user.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.RequestGlobalStatsAsync(System.Int32)">
            <summary>
            Asynchronously fetches global stats data, which is available for stats marked as 
            "aggregated" in the App Admin panel of the Steamworks website.
            You must have called RequestCurrentStats and it needs to return successfully via 
            its callback prior to calling this.
            </summary>
            <param name="days">How many days of day-by-day history to retrieve in addition to the overall totals. The limit is 60.</param>
            <returns>OK indicates success, InvalidState means you need to call RequestCurrentStats first, Fail means the remote call failed</returns>
        </member>
        <member name="M:Steamworks.SteamUserStats.FindOrCreateLeaderboardAsync(System.String,Steamworks.Data.LeaderboardSort,Steamworks.Data.LeaderboardDisplay)">
            <summary>
            Gets a leaderboard by name, it will create it if it's not yet created.
            Leaderboards created with this function will not automatically show up in the Steam Community.
            You must manually set the Community Name field in the App Admin panel of the Steamworks website. 
            As such it's generally recommended to prefer creating the leaderboards in the App Admin panel on 
            the Steamworks website and using FindLeaderboard unless you're expected to have a large amount of
            dynamically created leaderboards.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.AddStat(System.String,System.Int32)">
            <summary>
            Adds this amount to the named stat. Internally this calls Get() and adds 
            to that value. Steam doesn't provide a mechanism for atomically increasing
            stats like this, this functionality is added here as a convenience.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.AddStat(System.String,System.Single)">
            <summary>
            Adds this amount to the named stat. Internally this calls Get() and adds 
            to that value. Steam doesn't provide a mechanism for atomically increasing
            stats like this, this functionality is added here as a convenience.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.SetStat(System.String,System.Int32)">
            <summary>
            Set a stat value. This will automatically call StoreStats() after a successful call
            unless you pass false as the last argument.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.SetStat(System.String,System.Single)">
            <summary>
            Set a stat value. This will automatically call StoreStats() after a successful call
            unless you pass false as the last argument.
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.GetStatInt(System.String)">
            <summary>
            Get a Int stat value
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.GetStatFloat(System.String)">
            <summary>
            Get a float stat value
            </summary>
        </member>
        <member name="M:Steamworks.SteamUserStats.ResetAll(System.Boolean)">
            <summary>
            Practically wipes the slate clean for this user. If includeAchievements is true, will wipe
            any achievements too.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Steamworks.SteamUtils">
            <summary>
            Interface which provides access to a range of miscellaneous utility functions
            </summary>
        </member>
        <member name="E:Steamworks.SteamUtils.OnIpCountryChanged">
            <summary>
            The country of the user changed
            </summary>
        </member>
        <member name="E:Steamworks.SteamUtils.OnLowBatteryPower">
            <summary>
            Fired when running on a laptop and less than 10 minutes of battery is left, fires then every minute
            The parameter is the number of minutes left
            </summary>
        </member>
        <member name="E:Steamworks.SteamUtils.OnSteamShutdown">
            <summary>
            Called when Steam wants to shutdown
            </summary>
        </member>
        <member name="E:Steamworks.SteamUtils.OnGamepadTextInputDismissed">
            <summary>
            Big Picture gamepad text input has been closed. Parameter is true if text was submitted, false if cancelled etc.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.SecondsSinceAppActive">
            <summary>
            Returns the number of seconds since the application was active
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.SecondsSinceComputerActive">
            <summary>
            Returns the number of seconds since the user last moved the mouse etc
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.SteamServerTime">
            <summary>
            Steam server time.  Number of seconds since January 1, 1970, GMT (i.e unix time)
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IpCountry">
            <summary>
            returns the 2 digit ISO 3166-1-alpha-2 format country code this client is running in (as looked up via an IP-to-location database)
            e.g "US" or "UK".
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImageSize(System.Int32,System.UInt32@,System.UInt32@)">
            <summary>
            returns true if the image exists, and the buffer was successfully filled out
            results are returned in RGBA format
            the destination buffer size should be 4 * height * width * sizeof(char)
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetImage(System.Int32)">
            <summary>
            returns the image in RGBA format
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.UsingBatteryPower">
            <summary>
            Returns true if we're using a battery (ie, a laptop not plugged in)
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.CurrentBatteryPower">
            <summary>
            Returns battery power [0-1]
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.OverlayNotificationPosition">
            <summary>
            Sets the position where the overlay instance for the currently calling game should show notifications.
            This position is per-game and if this function is called from outside of a game context it will do nothing.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsOverlayEnabled">
            <summary>
            Returns true if the overlay is running and the user can access it. The overlay process could take a few seconds to
            start and hook the game process, so this function will initially return false while the overlay is loading.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.DoesOverlayNeedPresent">
             <summary>
             Normally this call is unneeded if your game has a constantly running frame loop that calls the 
             D3D Present API, or OGL SwapBuffers API every frame.
            
             However, if you have a game that only refreshes the screen on an event driven basis then that can break 
             the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also
             need to Present() to the screen any time an even needing a notification happens or when the overlay is
             brought up over the game by a user.  You can use this API to ask the overlay if it currently need a present
             in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you
             refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.
             </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.CheckFileSignatureAsync(System.String)">
            <summary>
            Asynchronous call to check if an executable file has been signed using the internal key set on the signing tab
            of the partner site, for example to refuse to load modified executable files.  
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.ShowGamepadTextInput(Steamworks.GamepadTextInputMode,Steamworks.GamepadTextInputLineMode,System.String,System.Int32,System.String)">
            <summary>
            Activates the Big Picture text input dialog which only supports gamepad input
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.GetEnteredGamepadText">
            <summary>
            Returns previously entered text
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.SteamUILanguage">
            <summary>
            returns the language the steam client is running in, you probably want 
            Apps.CurrentGameLanguage instead, this is for very special usage cases
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsSteamRunningInVR">
            <summary>
            returns true if Steam itself is running in VR mode
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.SetOverlayNotificationInset(System.Int32,System.Int32)">
            <summary>
            Sets the inset of the overlay notification from the corner specified by SetOverlayNotificationPosition
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsSteamInBigPictureMode">
            <summary>
            returns true if Steam and the Steam Overlay are running in Big Picture mode
            Games much be launched through the Steam client to enable the Big Picture overlay. During development,
            a game can be added as a non-steam game to the developers library to test this feature
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.StartVRDashboard">
            <summary>
            ask SteamUI to create and render its OpenVR dashboard
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.VrHeadsetStreaming">
            <summary>
            Set whether the HMD content will be streamed via Steam In-Home Streaming
            If this is set to true, then the scene in the HMD headset will be streamed, and remote input will not be allowed.
            If this is set to false, then the application window will be streamed instead, and remote input will be allowed.
            The default is true unless "VRHeadsetStreaming" "0" is in the extended appinfo for a game.
            (this is useful for games that have asymmetric multiplayer gameplay)
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsSteamChinaLauncher">
            <summary>
            Returns whether this steam client is a Steam China specific client, vs the global client
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.InitFilterText">
            <summary>
            Initializes text filtering, loading dictionaries for the language the game is running in.
            Users can customize the text filter behavior in their Steam Account preferences
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.FilterText(Steamworks.TextFilteringContext,Steamworks.SteamId,System.String)">
            <summary>
            Filters the provided input message and places the filtered result into pchOutFilteredText,
            using legally required filtering and additional filtering based on the context and user settings.
            </summary>
        </member>
        <member name="P:Steamworks.SteamUtils.IsRunningOnSteamDeck">
            <summary>
            returns true if Steam itself is running on the Steam Deck
            </summary>
        </member>
        <member name="M:Steamworks.SteamUtils.SetGameLauncherMode(System.Boolean)">
            <summary>
            In game launchers that don't have controller support you can call this to have 
            Steam Input translate the controller input into mouse/kb to navigate the launcher
            </summary>
        </member>
        <member name="P:Steamworks.Clan.Official">
            <summary>
            Is the clan an official game group?
            </summary>
        </member>
        <member name="M:Steamworks.Clan.RequestOfficerList">
            <summary>
            Asynchronously fetches the officer list for a given clan
            </summary>
            <returns>Whether the request was successful or not</returns>
        </member>
        <member name="P:Steamworks.Friend.IsMe">
            <summary>
            Returns true if this is the local user
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsFriend">
            <summary>
            Return true if this is a friend
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBlocked">
            <summary>
            Returns true if you have this user blocked
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlayingThisGame">
            <summary>
            Return true if this user is playing the game we're running
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsPlaying">
            <summary>
            Return true if this user is playing another game
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsOnline">
            <summary>
            Returns true if this friend is online
            </summary>
        </member>
        <member name="M:Steamworks.Friend.RequestInfoAsync">
            <summary>
            Sometimes we don't know the user's name. This will wait until we have
            downloaded the information on this user.
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsAway">
            <summary>
            Returns true if this friend is marked as away
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsBusy">
            <summary>
            Returns true if this friend is marked as busy
            </summary>
        </member>
        <member name="P:Steamworks.Friend.IsSnoozing">
            <summary>
            Returns true if this friend is marked as snoozing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.InviteToGame(System.String)">
            <summary>
            Invite this friend to the game that we are playing
            </summary>
        </member>
        <member name="M:Steamworks.Friend.SendMessage(System.String)">
            <summary>
            Sends a message to a Steam friend. Returns true if success
            </summary>
        </member>
        <member name="M:Steamworks.Friend.RequestUserStatsAsync">
            <summary>
            Tries to get download the latest user stats
            </summary>
            <returns>True if successful, False if failure</returns>
        </member>
        <member name="M:Steamworks.Friend.GetStatFloat(System.String,System.Single)">
            <summary>
            Gets a user stat. Must call RequestUserStats first.
            </summary>
            <param name="statName">The name of the stat you want to get</param>
            <param name="defult">Will return this value if not available</param>
            <returns>The value, or defult if not available</returns>
        </member>
        <member name="M:Steamworks.Friend.GetStatInt(System.String,System.Int32)">
            <summary>
            Gets a user stat. Must call RequestUserStats first.
            </summary>
            <param name="statName">The name of the stat you want to get</param>
            <param name="defult">Will return this value if not available</param>
            <returns>The value, or defult if not available</returns>
        </member>
        <member name="M:Steamworks.Friend.GetAchievement(System.String,System.Boolean)">
            <summary>
            Gets a user achievement state. Must call RequestUserStats first.
            </summary>
            <param name="statName">The name of the achievement you want to get</param>
            <param name="defult">Will return this value if not available</param>
            <returns>The value, or defult if not available</returns>
        </member>
        <member name="M:Steamworks.Friend.GetAchievementUnlockTime(System.String)">
            <summary>
            Gets a the time this achievement was unlocked.
            </summary>
            <param name="statName">The name of the achievement you want to get</param>
            <returns>The time unlocked. If it wasn't unlocked, or you haven't downloaded the stats yet - will return DateTime.MinValue</returns>
        </member>
        <member name="P:Steamworks.InventoryDef.Name">
            <summary>
            Shortcut to call GetProperty( "name" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Description">
            <summary>
            Shortcut to call GetProperty( "description" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.IconUrl">
            <summary>
            Shortcut to call GetProperty( "icon_url" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.IconUrlLarge">
            <summary>
            Shortcut to call GetProperty( "icon_url_large" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.PriceCategory">
            <summary>
            Shortcut to call GetProperty( "price_category" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Type">
            <summary>
            Shortcut to call GetProperty( "type" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.IsGenerator">
            <summary>
            Returns true if this is an item that generates an item, rather 
            than something that is actual an item
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.ExchangeSchema">
            <summary>
            Shortcut to call GetProperty( "exchange" )
            </summary>
        </member>
        <member name="M:Steamworks.InventoryDef.GetRecipes">
            <summary>
            Get a list of exchanges that are available to make this item
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Marketable">
            <summary>
            Shortcut to call GetBoolProperty( "marketable" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Tradable">
            <summary>
            Shortcut to call GetBoolProperty( "tradable" )
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Created">
            <summary>
            Gets the property timestamp
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Modified">
            <summary>
            Gets the property modified
            </summary>
        </member>
        <member name="M:Steamworks.InventoryDef.GetProperty(System.String)">
            <summary>
            Get a specific property by name
            </summary>
        </member>
        <member name="M:Steamworks.InventoryDef.GetBoolProperty(System.String)">
            <summary>
            Read a raw property from the definition schema
            </summary>
        </member>
        <member name="M:Steamworks.InventoryDef.GetProperty``1(System.String)">
            <summary>
            Read a raw property from the definition schema
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.Properties">
            <summary>
            Gets a list of all properties on this item
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.LocalPrice">
            <summary>
            Returns the price of this item in the local currency (SteamInventory.Currency)
            </summary>
        </member>
        <member name="P:Steamworks.InventoryDef.LocalBasePrice">
            <summary>
            If the price has been discounted, LocalPrice will differ from LocalBasePrice
            (assumed, this isn't documented)
            </summary>
        </member>
        <member name="M:Steamworks.InventoryDef.GetRecipesContainingThis">
            <summary>
            Return a list of recepies that contain this item
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.Properties">
            <summary>
            Only available if the result set was created with the getproperties
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.IsNoTrade">
            <summary>
            This item is account-locked and cannot be traded or given away. 
            This is an item status flag which is permanently attached to specific item instances
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.IsRemoved">
            <summary>
            The item has been destroyed, traded away, expired, or otherwise invalidated. 
            This is an action confirmation flag which is only set one time, as part of a result set.
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.IsConsumed">
            <summary>
            The item quantity has been decreased by 1 via ConsumeItem API. 
            This is an action confirmation flag which is only set one time, as part of a result set.
            </summary>
        </member>
        <member name="M:Steamworks.InventoryItem.ConsumeAsync(System.Int32)">
            <summary>
            Consumes items from a user's inventory. If the quantity of the given item goes to zero, it is permanently removed.
            Once an item is removed it cannot be recovered.This is not for the faint of heart - if your game implements item removal at all, 
            a high-friction UI confirmation process is highly recommended.ConsumeItem can be restricted to certain item definitions or fully
            blocked via the Steamworks website to minimize support/abuse issues such as the classic "my brother borrowed my laptop and deleted all of my rare items".
            </summary>
        </member>
        <member name="M:Steamworks.InventoryItem.SplitStackAsync(System.Int32)">
            <summary>
            Split stack into two items
            </summary>
        </member>
        <member name="M:Steamworks.InventoryItem.AddAsync(Steamworks.InventoryItem,System.Int32)">
            <summary>
            Add x units of the target item to this item
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.Acquired">
            <summary>
            Will try to return the date that this item was aquired. You need to have for the items
            with their properties for this to work.
            </summary>
        </member>
        <member name="P:Steamworks.InventoryItem.Origin">
            <summary>
            Tries to get the origin property. Need properties for this to work.
            Will return a string like "market"
            </summary>
        </member>
        <member name="T:Steamworks.InventoryItem.Amount">
            <summary>
            Small utility class to describe an item with a quantity
            </summary>
        </member>
        <member name="T:Steamworks.InventoryRecipe">
            <summary>
            A structured description of an item exchange
            </summary>
        </member>
        <member name="F:Steamworks.InventoryRecipe.Ingredient.DefinitionId">
            <summary>
            The definition ID of the ingredient.
            </summary>
        </member>
        <member name="F:Steamworks.InventoryRecipe.Ingredient.Definition">
            <summary>
            If we don't know about this item definition this might be null.
            In which case, DefinitionId should still hold the correct id.
            </summary>
        </member>
        <member name="F:Steamworks.InventoryRecipe.Ingredient.Count">
            <summary>
            The amount of this item needed. Generally this will be 1.
            </summary>
        </member>
        <member name="F:Steamworks.InventoryRecipe.Result">
            <summary>
            The item that this will create.
            </summary>
        </member>
        <member name="F:Steamworks.InventoryRecipe.Ingredients">
            <summary>
            The items, with quantity required to create this item.
            </summary>
        </member>
        <member name="M:Steamworks.InventoryResult.BelongsTo(Steamworks.SteamId)">
            <summary>
            Checks whether an inventory result handle belongs to the specified Steam ID.
            This is important when using Deserialize, to verify that a remote player is not pretending to have a different user's inventory
            </summary>
        </member>
        <member name="M:Steamworks.InventoryResult.Serialize">
            <summary>
            Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.
            A result set can be serialized on the local client, transmitted to other players via your game networking, and 
            deserialized by the remote players.This is a secure way of preventing hackers from lying about posessing 
            rare/high-value items. Serializes a result set with signature bytes to an output buffer.The size of a serialized 
            result depends on the number items which are being serialized.When securely transmitting items to other players, 
            it is recommended to use GetItemsByID first to create a minimal result set.
            Results have a built-in timestamp which will be considered "expired" after an hour has elapsed.See DeserializeResult
            for expiration handling.
            </summary>
        </member>
        <member name="T:Steamworks.SteamServerInit">
            <summary>
            Used to set up the server. 
            The variables in here are all required to be set, and can't be changed once the server is created.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.VersionString">
            <summary>
            The version string is usually in the form x.x.x.x, and is used by the master server to detect when the server is out of date.
            If you go into the dedicated server tab on steamworks you'll be able to server the latest version. If this version number is
            less than that latest version then your server won't show.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.ModDir">
            <summary>
            This should be the same directory game where gets installed into. Just the folder name, not the whole path. I.e. "Rust", "Garrysmod".
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.GameDescription">
            <summary>
            The game description. Setting this to the full name of your game is recommended.
            </summary>
        </member>
        <member name="F:Steamworks.SteamServerInit.DedicatedServer">
            <summary>
            Is a dedicated server
            </summary>
        </member>
        <member name="M:Steamworks.SteamServerInit.WithRandomSteamPort">
            <summary>
            Set the Steam quert port 
            </summary>
        </member>
        <member name="M:Steamworks.SteamServerInit.WithQueryShareGamePort">
            <summary>
            If you pass MASTERSERVERUPDATERPORT_USEGAMESOCKETSHARE into usQueryPort, then it causes the game server API to use 
            "GameSocketShare" mode, which means that the game is responsible for sending and receiving UDP packets for the master
            server updater.
            
            More info about this here: https://partner.steamgames.com/doc/api/ISteamGameServer#HandleIncomingPacket
            </summary>
        </member>
        <member name="P:Steamworks.Epoch.Current">
            <summary>
            Returns the current Unix Epoch
            </summary>
        </member>
        <member name="M:Steamworks.Epoch.ToDateTime(System.Decimal)">
            <summary>
            Convert an epoch to a datetime
            </summary>
        </member>
        <member name="M:Steamworks.Epoch.FromDateTime(System.DateTime)">
            <summary>
            Convert a DateTime to a unix time
            </summary>
        </member>
        <member name="M:Steamworks.Helpers.TakeBuffer(System.Int32)">
            <summary>
            Returns a buffer. This will get returned and reused later on.
            We shouldn't really be using this anymore. 
            </summary>
        </member>
        <member name="T:Steamworks.PreserveAttribute">
            <summary>
            Prevent unity from stripping shit we depend on
            https://docs.unity3d.com/Manual/ManagedCodeStripping.html
            </summary>
        </member>
    </members>
</doc>
